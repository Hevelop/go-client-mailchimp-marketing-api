/*
Mailchimp Marketing API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.55
Contact: apihelp@mailchimp.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mailchimpmarketingapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


type AutomationsAPI interface {

	/*
	ArchiveAutomations Archive automation

	Archiving will permanently end your automation and keep the report data. You’ll be able to replicate your archived automation, but you can’t restart it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@return AutomationsAPIArchiveAutomationsRequest
	*/
	ArchiveAutomations(ctx context.Context, workflowId string) AutomationsAPIArchiveAutomationsRequest

	// ArchiveAutomationsExecute executes the request
	ArchiveAutomationsExecute(r AutomationsAPIArchiveAutomationsRequest) (*http.Response, error)

	/*
	DeleteAutomationsIdEmailsId Delete workflow email

	Removes an individual classic automation workflow email. Emails from certain workflow types, including the Abandoned Cart Email (abandonedCart) and Product Retargeting Email (abandonedBrowse) Workflows, cannot be deleted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@param workflowEmailId The unique id for the Automation workflow email.
	@return AutomationsAPIDeleteAutomationsIdEmailsIdRequest
	*/
	DeleteAutomationsIdEmailsId(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIDeleteAutomationsIdEmailsIdRequest

	// DeleteAutomationsIdEmailsIdExecute executes the request
	DeleteAutomationsIdEmailsIdExecute(r AutomationsAPIDeleteAutomationsIdEmailsIdRequest) (*http.Response, error)

	/*
	GetAutomations List automations

	Get a summary of an account's classic automations.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AutomationsAPIGetAutomationsRequest
	*/
	GetAutomations(ctx context.Context) AutomationsAPIGetAutomationsRequest

	// GetAutomationsExecute executes the request
	//  @return GetAutomations200Response
	GetAutomationsExecute(r AutomationsAPIGetAutomationsRequest) (*GetAutomations200Response, *http.Response, error)

	/*
	GetAutomationsId Get automation info

	Get a summary of an individual classic automation workflow's settings and content. The `trigger_settings` object returns information for the first email in the workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@return AutomationsAPIGetAutomationsIdRequest
	*/
	GetAutomationsId(ctx context.Context, workflowId string) AutomationsAPIGetAutomationsIdRequest

	// GetAutomationsIdExecute executes the request
	//  @return AutomationWorkflow
	GetAutomationsIdExecute(r AutomationsAPIGetAutomationsIdRequest) (*AutomationWorkflow, *http.Response, error)

	/*
	GetAutomationsIdEmails List automated emails

	Get a summary of the emails in a classic automation workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@return AutomationsAPIGetAutomationsIdEmailsRequest
	*/
	GetAutomationsIdEmails(ctx context.Context, workflowId string) AutomationsAPIGetAutomationsIdEmailsRequest

	// GetAutomationsIdEmailsExecute executes the request
	//  @return AutomationEmails
	GetAutomationsIdEmailsExecute(r AutomationsAPIGetAutomationsIdEmailsRequest) (*AutomationEmails, *http.Response, error)

	/*
	GetAutomationsIdEmailsId Get workflow email info

	Get information about an individual classic automation workflow email.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@param workflowEmailId The unique id for the Automation workflow email.
	@return AutomationsAPIGetAutomationsIdEmailsIdRequest
	*/
	GetAutomationsIdEmailsId(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIGetAutomationsIdEmailsIdRequest

	// GetAutomationsIdEmailsIdExecute executes the request
	//  @return AutomationWorkflowEmail
	GetAutomationsIdEmailsIdExecute(r AutomationsAPIGetAutomationsIdEmailsIdRequest) (*AutomationWorkflowEmail, *http.Response, error)

	/*
	GetAutomationsIdEmailsIdQueue List automated email subscribers

	Get information about a classic automation email queue.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@param workflowEmailId The unique id for the Automation workflow email.
	@return AutomationsAPIGetAutomationsIdEmailsIdQueueRequest
	*/
	GetAutomationsIdEmailsIdQueue(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIGetAutomationsIdEmailsIdQueueRequest

	// GetAutomationsIdEmailsIdQueueExecute executes the request
	//  @return GetAutomationsIdEmailsIdQueue200Response
	GetAutomationsIdEmailsIdQueueExecute(r AutomationsAPIGetAutomationsIdEmailsIdQueueRequest) (*GetAutomationsIdEmailsIdQueue200Response, *http.Response, error)

	/*
	GetAutomationsIdEmailsIdQueueId Get automated email subscriber

	Get information about a specific subscriber in a classic automation email queue.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@param workflowEmailId The unique id for the Automation workflow email.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
	@return AutomationsAPIGetAutomationsIdEmailsIdQueueIdRequest
	*/
	GetAutomationsIdEmailsIdQueueId(ctx context.Context, workflowId string, workflowEmailId string, subscriberHash string) AutomationsAPIGetAutomationsIdEmailsIdQueueIdRequest

	// GetAutomationsIdEmailsIdQueueIdExecute executes the request
	//  @return SubscriberInAutomationQueue2
	GetAutomationsIdEmailsIdQueueIdExecute(r AutomationsAPIGetAutomationsIdEmailsIdQueueIdRequest) (*SubscriberInAutomationQueue2, *http.Response, error)

	/*
	GetAutomationsIdRemovedSubscribers List subscribers removed from workflow

	Get information about subscribers who were removed from a classic automation workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@return AutomationsAPIGetAutomationsIdRemovedSubscribersRequest
	*/
	GetAutomationsIdRemovedSubscribers(ctx context.Context, workflowId string) AutomationsAPIGetAutomationsIdRemovedSubscribersRequest

	// GetAutomationsIdRemovedSubscribersExecute executes the request
	//  @return RemovedSubscribers
	GetAutomationsIdRemovedSubscribersExecute(r AutomationsAPIGetAutomationsIdRemovedSubscribersRequest) (*RemovedSubscribers, *http.Response, error)

	/*
	GetAutomationsIdRemovedSubscribersId Get subscriber removed from workflow

	Get information about a specific subscriber who was removed from a classic automation workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
	@return AutomationsAPIGetAutomationsIdRemovedSubscribersIdRequest
	*/
	GetAutomationsIdRemovedSubscribersId(ctx context.Context, workflowId string, subscriberHash string) AutomationsAPIGetAutomationsIdRemovedSubscribersIdRequest

	// GetAutomationsIdRemovedSubscribersIdExecute executes the request
	//  @return SubscriberRemovedFromAutomationWorkflow
	GetAutomationsIdRemovedSubscribersIdExecute(r AutomationsAPIGetAutomationsIdRemovedSubscribersIdRequest) (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error)

	/*
	PatchAutomationEmailWorkflowId Update workflow email

	Update settings for a classic automation workflow email.  Only works with workflows of type: abandonedBrowse, abandonedCart, emailFollowup, or singleWelcome.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@param workflowEmailId The unique id for the Automation workflow email.
	@return AutomationsAPIPatchAutomationEmailWorkflowIdRequest
	*/
	PatchAutomationEmailWorkflowId(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIPatchAutomationEmailWorkflowIdRequest

	// PatchAutomationEmailWorkflowIdExecute executes the request
	//  @return AutomationWorkflowEmail
	PatchAutomationEmailWorkflowIdExecute(r AutomationsAPIPatchAutomationEmailWorkflowIdRequest) (*AutomationWorkflowEmail, *http.Response, error)

	/*
	PostAutomations Add automation

	Create a new classic automation in your Mailchimp account.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return AutomationsAPIPostAutomationsRequest
	*/
	PostAutomations(ctx context.Context) AutomationsAPIPostAutomationsRequest

	// PostAutomationsExecute executes the request
	//  @return AutomationWorkflow
	PostAutomationsExecute(r AutomationsAPIPostAutomationsRequest) (*AutomationWorkflow, *http.Response, error)

	/*
	PostAutomationsIdActionsPauseAllEmails Pause automation emails

	Pause all emails in a specific classic automation workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@return AutomationsAPIPostAutomationsIdActionsPauseAllEmailsRequest
	*/
	PostAutomationsIdActionsPauseAllEmails(ctx context.Context, workflowId string) AutomationsAPIPostAutomationsIdActionsPauseAllEmailsRequest

	// PostAutomationsIdActionsPauseAllEmailsExecute executes the request
	PostAutomationsIdActionsPauseAllEmailsExecute(r AutomationsAPIPostAutomationsIdActionsPauseAllEmailsRequest) (*http.Response, error)

	/*
	PostAutomationsIdActionsStartAllEmails Start automation emails

	Start all emails in a classic automation workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@return AutomationsAPIPostAutomationsIdActionsStartAllEmailsRequest
	*/
	PostAutomationsIdActionsStartAllEmails(ctx context.Context, workflowId string) AutomationsAPIPostAutomationsIdActionsStartAllEmailsRequest

	// PostAutomationsIdActionsStartAllEmailsExecute executes the request
	PostAutomationsIdActionsStartAllEmailsExecute(r AutomationsAPIPostAutomationsIdActionsStartAllEmailsRequest) (*http.Response, error)

	/*
	PostAutomationsIdEmailsIdActionsPause Pause automated email

	Pause an automated email.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@param workflowEmailId The unique id for the Automation workflow email.
	@return AutomationsAPIPostAutomationsIdEmailsIdActionsPauseRequest
	*/
	PostAutomationsIdEmailsIdActionsPause(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIPostAutomationsIdEmailsIdActionsPauseRequest

	// PostAutomationsIdEmailsIdActionsPauseExecute executes the request
	PostAutomationsIdEmailsIdActionsPauseExecute(r AutomationsAPIPostAutomationsIdEmailsIdActionsPauseRequest) (*http.Response, error)

	/*
	PostAutomationsIdEmailsIdActionsStart Start automated email

	Start an automated email.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@param workflowEmailId The unique id for the Automation workflow email.
	@return AutomationsAPIPostAutomationsIdEmailsIdActionsStartRequest
	*/
	PostAutomationsIdEmailsIdActionsStart(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIPostAutomationsIdEmailsIdActionsStartRequest

	// PostAutomationsIdEmailsIdActionsStartExecute executes the request
	PostAutomationsIdEmailsIdActionsStartExecute(r AutomationsAPIPostAutomationsIdEmailsIdActionsStartRequest) (*http.Response, error)

	/*
	PostAutomationsIdEmailsIdQueue Add subscriber to workflow email

	Manually add a subscriber to a workflow, bypassing the default trigger settings. You can also use this endpoint to trigger a series of automated emails in an API 3.0 workflow type.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@param workflowEmailId The unique id for the Automation workflow email.
	@return AutomationsAPIPostAutomationsIdEmailsIdQueueRequest
	*/
	PostAutomationsIdEmailsIdQueue(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIPostAutomationsIdEmailsIdQueueRequest

	// PostAutomationsIdEmailsIdQueueExecute executes the request
	//  @return SubscriberInAutomationQueue2
	PostAutomationsIdEmailsIdQueueExecute(r AutomationsAPIPostAutomationsIdEmailsIdQueueRequest) (*SubscriberInAutomationQueue2, *http.Response, error)

	/*
	PostAutomationsIdRemovedSubscribers Remove subscriber from workflow

	Remove a subscriber from a specific classic automation workflow. You can remove a subscriber at any point in an automation workflow, regardless of how many emails they've been sent from that workflow. Once they're removed, they can never be added back to the same workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param workflowId The unique id for the Automation workflow.
	@return AutomationsAPIPostAutomationsIdRemovedSubscribersRequest
	*/
	PostAutomationsIdRemovedSubscribers(ctx context.Context, workflowId string) AutomationsAPIPostAutomationsIdRemovedSubscribersRequest

	// PostAutomationsIdRemovedSubscribersExecute executes the request
	//  @return SubscriberRemovedFromAutomationWorkflow
	PostAutomationsIdRemovedSubscribersExecute(r AutomationsAPIPostAutomationsIdRemovedSubscribersRequest) (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error)
}

// AutomationsAPIService AutomationsAPI service
type AutomationsAPIService service

type AutomationsAPIArchiveAutomationsRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
}

func (r AutomationsAPIArchiveAutomationsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ArchiveAutomationsExecute(r)
}

/*
ArchiveAutomations Archive automation

Archiving will permanently end your automation and keep the report data. You’ll be able to replicate your archived automation, but you can’t restart it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return AutomationsAPIArchiveAutomationsRequest
*/
func (a *AutomationsAPIService) ArchiveAutomations(ctx context.Context, workflowId string) AutomationsAPIArchiveAutomationsRequest {
	return AutomationsAPIArchiveAutomationsRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) ArchiveAutomationsExecute(r AutomationsAPIArchiveAutomationsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.ArchiveAutomations")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/actions/archive"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AutomationsAPIDeleteAutomationsIdEmailsIdRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	workflowEmailId string
}

func (r AutomationsAPIDeleteAutomationsIdEmailsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAutomationsIdEmailsIdExecute(r)
}

/*
DeleteAutomationsIdEmailsId Delete workflow email

Removes an individual classic automation workflow email. Emails from certain workflow types, including the Abandoned Cart Email (abandonedCart) and Product Retargeting Email (abandonedBrowse) Workflows, cannot be deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return AutomationsAPIDeleteAutomationsIdEmailsIdRequest
*/
func (a *AutomationsAPIService) DeleteAutomationsIdEmailsId(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIDeleteAutomationsIdEmailsIdRequest {
	return AutomationsAPIDeleteAutomationsIdEmailsIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) DeleteAutomationsIdEmailsIdExecute(r AutomationsAPIDeleteAutomationsIdEmailsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.DeleteAutomationsIdEmailsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AutomationsAPIGetAutomationsRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	count *int32
	offset *int32
	fields *[]string
	excludeFields *[]string
	beforeCreateTime *time.Time
	sinceCreateTime *time.Time
	beforeStartTime *time.Time
	sinceStartTime *time.Time
	status *string
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r AutomationsAPIGetAutomationsRequest) Count(count int32) AutomationsAPIGetAutomationsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r AutomationsAPIGetAutomationsRequest) Offset(offset int32) AutomationsAPIGetAutomationsRequest {
	r.offset = &offset
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r AutomationsAPIGetAutomationsRequest) Fields(fields []string) AutomationsAPIGetAutomationsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r AutomationsAPIGetAutomationsRequest) ExcludeFields(excludeFields []string) AutomationsAPIGetAutomationsRequest {
	r.excludeFields = &excludeFields
	return r
}

// Restrict the response to automations created before this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r AutomationsAPIGetAutomationsRequest) BeforeCreateTime(beforeCreateTime time.Time) AutomationsAPIGetAutomationsRequest {
	r.beforeCreateTime = &beforeCreateTime
	return r
}

// Restrict the response to automations created after this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r AutomationsAPIGetAutomationsRequest) SinceCreateTime(sinceCreateTime time.Time) AutomationsAPIGetAutomationsRequest {
	r.sinceCreateTime = &sinceCreateTime
	return r
}

// Restrict the response to automations started before this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r AutomationsAPIGetAutomationsRequest) BeforeStartTime(beforeStartTime time.Time) AutomationsAPIGetAutomationsRequest {
	r.beforeStartTime = &beforeStartTime
	return r
}

// Restrict the response to automations started after this time. Uses the ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r AutomationsAPIGetAutomationsRequest) SinceStartTime(sinceStartTime time.Time) AutomationsAPIGetAutomationsRequest {
	r.sinceStartTime = &sinceStartTime
	return r
}

// Restrict the results to automations with the specified status.
func (r AutomationsAPIGetAutomationsRequest) Status(status string) AutomationsAPIGetAutomationsRequest {
	r.status = &status
	return r
}

func (r AutomationsAPIGetAutomationsRequest) Execute() (*GetAutomations200Response, *http.Response, error) {
	return r.ApiService.GetAutomationsExecute(r)
}

/*
GetAutomations List automations

Get a summary of an account's classic automations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AutomationsAPIGetAutomationsRequest
*/
func (a *AutomationsAPIService) GetAutomations(ctx context.Context) AutomationsAPIGetAutomationsRequest {
	return AutomationsAPIGetAutomationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAutomations200Response
func (a *AutomationsAPIService) GetAutomationsExecute(r AutomationsAPIGetAutomationsRequest) (*GetAutomations200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAutomations200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.beforeCreateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_create_time", r.beforeCreateTime, "")
	}
	if r.sinceCreateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_create_time", r.sinceCreateTime, "")
	}
	if r.beforeStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_start_time", r.beforeStartTime, "")
	}
	if r.sinceStartTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_start_time", r.sinceStartTime, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIGetAutomationsIdRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r AutomationsAPIGetAutomationsIdRequest) Fields(fields []string) AutomationsAPIGetAutomationsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r AutomationsAPIGetAutomationsIdRequest) ExcludeFields(excludeFields []string) AutomationsAPIGetAutomationsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r AutomationsAPIGetAutomationsIdRequest) Execute() (*AutomationWorkflow, *http.Response, error) {
	return r.ApiService.GetAutomationsIdExecute(r)
}

/*
GetAutomationsId Get automation info

Get a summary of an individual classic automation workflow's settings and content. The `trigger_settings` object returns information for the first email in the workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return AutomationsAPIGetAutomationsIdRequest
*/
func (a *AutomationsAPIService) GetAutomationsId(ctx context.Context, workflowId string) AutomationsAPIGetAutomationsIdRequest {
	return AutomationsAPIGetAutomationsIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return AutomationWorkflow
func (a *AutomationsAPIService) GetAutomationsIdExecute(r AutomationsAPIGetAutomationsIdRequest) (*AutomationWorkflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationWorkflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIGetAutomationsIdEmailsRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
}

func (r AutomationsAPIGetAutomationsIdEmailsRequest) Execute() (*AutomationEmails, *http.Response, error) {
	return r.ApiService.GetAutomationsIdEmailsExecute(r)
}

/*
GetAutomationsIdEmails List automated emails

Get a summary of the emails in a classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return AutomationsAPIGetAutomationsIdEmailsRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdEmails(ctx context.Context, workflowId string) AutomationsAPIGetAutomationsIdEmailsRequest {
	return AutomationsAPIGetAutomationsIdEmailsRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return AutomationEmails
func (a *AutomationsAPIService) GetAutomationsIdEmailsExecute(r AutomationsAPIGetAutomationsIdEmailsRequest) (*AutomationEmails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationEmails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdEmails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIGetAutomationsIdEmailsIdRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	workflowEmailId string
}

func (r AutomationsAPIGetAutomationsIdEmailsIdRequest) Execute() (*AutomationWorkflowEmail, *http.Response, error) {
	return r.ApiService.GetAutomationsIdEmailsIdExecute(r)
}

/*
GetAutomationsIdEmailsId Get workflow email info

Get information about an individual classic automation workflow email.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return AutomationsAPIGetAutomationsIdEmailsIdRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdEmailsId(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIGetAutomationsIdEmailsIdRequest {
	return AutomationsAPIGetAutomationsIdEmailsIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
//  @return AutomationWorkflowEmail
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdExecute(r AutomationsAPIGetAutomationsIdEmailsIdRequest) (*AutomationWorkflowEmail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationWorkflowEmail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdEmailsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIGetAutomationsIdEmailsIdQueueRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	workflowEmailId string
}

func (r AutomationsAPIGetAutomationsIdEmailsIdQueueRequest) Execute() (*GetAutomationsIdEmailsIdQueue200Response, *http.Response, error) {
	return r.ApiService.GetAutomationsIdEmailsIdQueueExecute(r)
}

/*
GetAutomationsIdEmailsIdQueue List automated email subscribers

Get information about a classic automation email queue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return AutomationsAPIGetAutomationsIdEmailsIdQueueRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdQueue(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIGetAutomationsIdEmailsIdQueueRequest {
	return AutomationsAPIGetAutomationsIdEmailsIdQueueRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
//  @return GetAutomationsIdEmailsIdQueue200Response
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdQueueExecute(r AutomationsAPIGetAutomationsIdEmailsIdQueueRequest) (*GetAutomationsIdEmailsIdQueue200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAutomationsIdEmailsIdQueue200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdEmailsIdQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/queue"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIGetAutomationsIdEmailsIdQueueIdRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	workflowEmailId string
	subscriberHash string
}

func (r AutomationsAPIGetAutomationsIdEmailsIdQueueIdRequest) Execute() (*SubscriberInAutomationQueue2, *http.Response, error) {
	return r.ApiService.GetAutomationsIdEmailsIdQueueIdExecute(r)
}

/*
GetAutomationsIdEmailsIdQueueId Get automated email subscriber

Get information about a specific subscriber in a classic automation email queue.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return AutomationsAPIGetAutomationsIdEmailsIdQueueIdRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdQueueId(ctx context.Context, workflowId string, workflowEmailId string, subscriberHash string) AutomationsAPIGetAutomationsIdEmailsIdQueueIdRequest {
	return AutomationsAPIGetAutomationsIdEmailsIdQueueIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return SubscriberInAutomationQueue2
func (a *AutomationsAPIService) GetAutomationsIdEmailsIdQueueIdExecute(r AutomationsAPIGetAutomationsIdEmailsIdQueueIdRequest) (*SubscriberInAutomationQueue2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberInAutomationQueue2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdEmailsIdQueueId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/queue/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIGetAutomationsIdRemovedSubscribersRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
}

func (r AutomationsAPIGetAutomationsIdRemovedSubscribersRequest) Execute() (*RemovedSubscribers, *http.Response, error) {
	return r.ApiService.GetAutomationsIdRemovedSubscribersExecute(r)
}

/*
GetAutomationsIdRemovedSubscribers List subscribers removed from workflow

Get information about subscribers who were removed from a classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return AutomationsAPIGetAutomationsIdRemovedSubscribersRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdRemovedSubscribers(ctx context.Context, workflowId string) AutomationsAPIGetAutomationsIdRemovedSubscribersRequest {
	return AutomationsAPIGetAutomationsIdRemovedSubscribersRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return RemovedSubscribers
func (a *AutomationsAPIService) GetAutomationsIdRemovedSubscribersExecute(r AutomationsAPIGetAutomationsIdRemovedSubscribersRequest) (*RemovedSubscribers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemovedSubscribers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdRemovedSubscribers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/removed-subscribers"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIGetAutomationsIdRemovedSubscribersIdRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	subscriberHash string
}

func (r AutomationsAPIGetAutomationsIdRemovedSubscribersIdRequest) Execute() (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error) {
	return r.ApiService.GetAutomationsIdRemovedSubscribersIdExecute(r)
}

/*
GetAutomationsIdRemovedSubscribersId Get subscriber removed from workflow

Get information about a specific subscriber who was removed from a classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return AutomationsAPIGetAutomationsIdRemovedSubscribersIdRequest
*/
func (a *AutomationsAPIService) GetAutomationsIdRemovedSubscribersId(ctx context.Context, workflowId string, subscriberHash string) AutomationsAPIGetAutomationsIdRemovedSubscribersIdRequest {
	return AutomationsAPIGetAutomationsIdRemovedSubscribersIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return SubscriberRemovedFromAutomationWorkflow
func (a *AutomationsAPIService) GetAutomationsIdRemovedSubscribersIdExecute(r AutomationsAPIGetAutomationsIdRemovedSubscribersIdRequest) (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberRemovedFromAutomationWorkflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.GetAutomationsIdRemovedSubscribersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/removed-subscribers/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIPatchAutomationEmailWorkflowIdRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	workflowEmailId string
	body *UpdateInformationAboutASpecificWorkflowEmail
}

func (r AutomationsAPIPatchAutomationEmailWorkflowIdRequest) Body(body UpdateInformationAboutASpecificWorkflowEmail) AutomationsAPIPatchAutomationEmailWorkflowIdRequest {
	r.body = &body
	return r
}

func (r AutomationsAPIPatchAutomationEmailWorkflowIdRequest) Execute() (*AutomationWorkflowEmail, *http.Response, error) {
	return r.ApiService.PatchAutomationEmailWorkflowIdExecute(r)
}

/*
PatchAutomationEmailWorkflowId Update workflow email

Update settings for a classic automation workflow email.  Only works with workflows of type: abandonedBrowse, abandonedCart, emailFollowup, or singleWelcome.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return AutomationsAPIPatchAutomationEmailWorkflowIdRequest
*/
func (a *AutomationsAPIService) PatchAutomationEmailWorkflowId(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIPatchAutomationEmailWorkflowIdRequest {
	return AutomationsAPIPatchAutomationEmailWorkflowIdRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
//  @return AutomationWorkflowEmail
func (a *AutomationsAPIService) PatchAutomationEmailWorkflowIdExecute(r AutomationsAPIPatchAutomationEmailWorkflowIdRequest) (*AutomationWorkflowEmail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationWorkflowEmail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PatchAutomationEmailWorkflowId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIPostAutomationsRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	body *AutomationWorkflow1
}

func (r AutomationsAPIPostAutomationsRequest) Body(body AutomationWorkflow1) AutomationsAPIPostAutomationsRequest {
	r.body = &body
	return r
}

func (r AutomationsAPIPostAutomationsRequest) Execute() (*AutomationWorkflow, *http.Response, error) {
	return r.ApiService.PostAutomationsExecute(r)
}

/*
PostAutomations Add automation

Create a new classic automation in your Mailchimp account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return AutomationsAPIPostAutomationsRequest
*/
func (a *AutomationsAPIService) PostAutomations(ctx context.Context) AutomationsAPIPostAutomationsRequest {
	return AutomationsAPIPostAutomationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AutomationWorkflow
func (a *AutomationsAPIService) PostAutomationsExecute(r AutomationsAPIPostAutomationsRequest) (*AutomationWorkflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AutomationWorkflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIPostAutomationsIdActionsPauseAllEmailsRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
}

func (r AutomationsAPIPostAutomationsIdActionsPauseAllEmailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAutomationsIdActionsPauseAllEmailsExecute(r)
}

/*
PostAutomationsIdActionsPauseAllEmails Pause automation emails

Pause all emails in a specific classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return AutomationsAPIPostAutomationsIdActionsPauseAllEmailsRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdActionsPauseAllEmails(ctx context.Context, workflowId string) AutomationsAPIPostAutomationsIdActionsPauseAllEmailsRequest {
	return AutomationsAPIPostAutomationsIdActionsPauseAllEmailsRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) PostAutomationsIdActionsPauseAllEmailsExecute(r AutomationsAPIPostAutomationsIdActionsPauseAllEmailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdActionsPauseAllEmails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/actions/pause-all-emails"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AutomationsAPIPostAutomationsIdActionsStartAllEmailsRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
}

func (r AutomationsAPIPostAutomationsIdActionsStartAllEmailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAutomationsIdActionsStartAllEmailsExecute(r)
}

/*
PostAutomationsIdActionsStartAllEmails Start automation emails

Start all emails in a classic automation workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return AutomationsAPIPostAutomationsIdActionsStartAllEmailsRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdActionsStartAllEmails(ctx context.Context, workflowId string) AutomationsAPIPostAutomationsIdActionsStartAllEmailsRequest {
	return AutomationsAPIPostAutomationsIdActionsStartAllEmailsRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) PostAutomationsIdActionsStartAllEmailsExecute(r AutomationsAPIPostAutomationsIdActionsStartAllEmailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdActionsStartAllEmails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/actions/start-all-emails"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AutomationsAPIPostAutomationsIdEmailsIdActionsPauseRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	workflowEmailId string
}

func (r AutomationsAPIPostAutomationsIdEmailsIdActionsPauseRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAutomationsIdEmailsIdActionsPauseExecute(r)
}

/*
PostAutomationsIdEmailsIdActionsPause Pause automated email

Pause an automated email.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return AutomationsAPIPostAutomationsIdEmailsIdActionsPauseRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdActionsPause(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIPostAutomationsIdEmailsIdActionsPauseRequest {
	return AutomationsAPIPostAutomationsIdEmailsIdActionsPauseRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdActionsPauseExecute(r AutomationsAPIPostAutomationsIdEmailsIdActionsPauseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdEmailsIdActionsPause")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/actions/pause"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AutomationsAPIPostAutomationsIdEmailsIdActionsStartRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	workflowEmailId string
}

func (r AutomationsAPIPostAutomationsIdEmailsIdActionsStartRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostAutomationsIdEmailsIdActionsStartExecute(r)
}

/*
PostAutomationsIdEmailsIdActionsStart Start automated email

Start an automated email.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return AutomationsAPIPostAutomationsIdEmailsIdActionsStartRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdActionsStart(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIPostAutomationsIdEmailsIdActionsStartRequest {
	return AutomationsAPIPostAutomationsIdEmailsIdActionsStartRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdActionsStartExecute(r AutomationsAPIPostAutomationsIdEmailsIdActionsStartRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdEmailsIdActionsStart")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/actions/start"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AutomationsAPIPostAutomationsIdEmailsIdQueueRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	workflowEmailId string
	body *SubscriberInAutomationQueue1
}

func (r AutomationsAPIPostAutomationsIdEmailsIdQueueRequest) Body(body SubscriberInAutomationQueue1) AutomationsAPIPostAutomationsIdEmailsIdQueueRequest {
	r.body = &body
	return r
}

func (r AutomationsAPIPostAutomationsIdEmailsIdQueueRequest) Execute() (*SubscriberInAutomationQueue2, *http.Response, error) {
	return r.ApiService.PostAutomationsIdEmailsIdQueueExecute(r)
}

/*
PostAutomationsIdEmailsIdQueue Add subscriber to workflow email

Manually add a subscriber to a workflow, bypassing the default trigger settings. You can also use this endpoint to trigger a series of automated emails in an API 3.0 workflow type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @param workflowEmailId The unique id for the Automation workflow email.
 @return AutomationsAPIPostAutomationsIdEmailsIdQueueRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdQueue(ctx context.Context, workflowId string, workflowEmailId string) AutomationsAPIPostAutomationsIdEmailsIdQueueRequest {
	return AutomationsAPIPostAutomationsIdEmailsIdQueueRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
		workflowEmailId: workflowEmailId,
	}
}

// Execute executes the request
//  @return SubscriberInAutomationQueue2
func (a *AutomationsAPIService) PostAutomationsIdEmailsIdQueueExecute(r AutomationsAPIPostAutomationsIdEmailsIdQueueRequest) (*SubscriberInAutomationQueue2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberInAutomationQueue2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdEmailsIdQueue")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/emails/{workflow_email_id}/queue"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_email_id"+"}", url.PathEscape(parameterValueToString(r.workflowEmailId, "workflowEmailId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AutomationsAPIPostAutomationsIdRemovedSubscribersRequest struct {
	ctx context.Context
	ApiService AutomationsAPI
	workflowId string
	body *SubscriberInAutomationQueue1
}

func (r AutomationsAPIPostAutomationsIdRemovedSubscribersRequest) Body(body SubscriberInAutomationQueue1) AutomationsAPIPostAutomationsIdRemovedSubscribersRequest {
	r.body = &body
	return r
}

func (r AutomationsAPIPostAutomationsIdRemovedSubscribersRequest) Execute() (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error) {
	return r.ApiService.PostAutomationsIdRemovedSubscribersExecute(r)
}

/*
PostAutomationsIdRemovedSubscribers Remove subscriber from workflow

Remove a subscriber from a specific classic automation workflow. You can remove a subscriber at any point in an automation workflow, regardless of how many emails they've been sent from that workflow. Once they're removed, they can never be added back to the same workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowId The unique id for the Automation workflow.
 @return AutomationsAPIPostAutomationsIdRemovedSubscribersRequest
*/
func (a *AutomationsAPIService) PostAutomationsIdRemovedSubscribers(ctx context.Context, workflowId string) AutomationsAPIPostAutomationsIdRemovedSubscribersRequest {
	return AutomationsAPIPostAutomationsIdRemovedSubscribersRequest{
		ApiService: a,
		ctx: ctx,
		workflowId: workflowId,
	}
}

// Execute executes the request
//  @return SubscriberRemovedFromAutomationWorkflow
func (a *AutomationsAPIService) PostAutomationsIdRemovedSubscribersExecute(r AutomationsAPIPostAutomationsIdRemovedSubscribersRequest) (*SubscriberRemovedFromAutomationWorkflow, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberRemovedFromAutomationWorkflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AutomationsAPIService.PostAutomationsIdRemovedSubscribers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/automations/{workflow_id}/removed-subscribers"
	localVarPath = strings.Replace(localVarPath, "{"+"workflow_id"+"}", url.PathEscape(parameterValueToString(r.workflowId, "workflowId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
