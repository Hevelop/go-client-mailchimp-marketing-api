/*
Mailchimp Marketing API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.55
Contact: apihelp@mailchimp.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mailchimpmarketingapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


type ConversationsAPI interface {

	/*
	GetConversations List conversations

	Get a list of conversations for the account. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ConversationsAPIGetConversationsRequest

	Deprecated
	*/
	GetConversations(ctx context.Context) ConversationsAPIGetConversationsRequest

	// GetConversationsExecute executes the request
	//  @return TrackedConversations
	// Deprecated
	GetConversationsExecute(r ConversationsAPIGetConversationsRequest) (*TrackedConversations, *http.Response, error)

	/*
	GetConversationsId Get conversation

	Get details about an individual conversation. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId The unique id for the conversation.
	@return ConversationsAPIGetConversationsIdRequest

	Deprecated
	*/
	GetConversationsId(ctx context.Context, conversationId string) ConversationsAPIGetConversationsIdRequest

	// GetConversationsIdExecute executes the request
	//  @return Conversation
	// Deprecated
	GetConversationsIdExecute(r ConversationsAPIGetConversationsIdRequest) (*Conversation, *http.Response, error)

	/*
	GetConversationsIdMessages List messages

	Get messages from a specific conversation. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId The unique id for the conversation.
	@return ConversationsAPIGetConversationsIdMessagesRequest

	Deprecated
	*/
	GetConversationsIdMessages(ctx context.Context, conversationId string) ConversationsAPIGetConversationsIdMessagesRequest

	// GetConversationsIdMessagesExecute executes the request
	//  @return CollectionOfConversationMessages
	// Deprecated
	GetConversationsIdMessagesExecute(r ConversationsAPIGetConversationsIdMessagesRequest) (*CollectionOfConversationMessages, *http.Response, error)

	/*
	GetConversationsIdMessagesId Get message

	Get an individual message in a conversation. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param conversationId The unique id for the conversation.
	@param messageId The unique id for the conversation message.
	@return ConversationsAPIGetConversationsIdMessagesIdRequest

	Deprecated
	*/
	GetConversationsIdMessagesId(ctx context.Context, conversationId string, messageId string) ConversationsAPIGetConversationsIdMessagesIdRequest

	// GetConversationsIdMessagesIdExecute executes the request
	//  @return ConversationMessage
	// Deprecated
	GetConversationsIdMessagesIdExecute(r ConversationsAPIGetConversationsIdMessagesIdRequest) (*ConversationMessage, *http.Response, error)
}

// ConversationsAPIService ConversationsAPI service
type ConversationsAPIService service

type ConversationsAPIGetConversationsRequest struct {
	ctx context.Context
	ApiService ConversationsAPI
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	hasUnreadMessages *string
	listId *string
	campaignId *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ConversationsAPIGetConversationsRequest) Fields(fields []string) ConversationsAPIGetConversationsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ConversationsAPIGetConversationsRequest) ExcludeFields(excludeFields []string) ConversationsAPIGetConversationsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ConversationsAPIGetConversationsRequest) Count(count int32) ConversationsAPIGetConversationsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ConversationsAPIGetConversationsRequest) Offset(offset int32) ConversationsAPIGetConversationsRequest {
	r.offset = &offset
	return r
}

// Whether the conversation has any unread messages.
func (r ConversationsAPIGetConversationsRequest) HasUnreadMessages(hasUnreadMessages string) ConversationsAPIGetConversationsRequest {
	r.hasUnreadMessages = &hasUnreadMessages
	return r
}

// The unique id for the list.
func (r ConversationsAPIGetConversationsRequest) ListId(listId string) ConversationsAPIGetConversationsRequest {
	r.listId = &listId
	return r
}

// The unique id for the campaign.
func (r ConversationsAPIGetConversationsRequest) CampaignId(campaignId string) ConversationsAPIGetConversationsRequest {
	r.campaignId = &campaignId
	return r
}

func (r ConversationsAPIGetConversationsRequest) Execute() (*TrackedConversations, *http.Response, error) {
	return r.ApiService.GetConversationsExecute(r)
}

/*
GetConversations List conversations

Get a list of conversations for the account. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ConversationsAPIGetConversationsRequest

Deprecated
*/
func (a *ConversationsAPIService) GetConversations(ctx context.Context) ConversationsAPIGetConversationsRequest {
	return ConversationsAPIGetConversationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TrackedConversations
// Deprecated
func (a *ConversationsAPIService) GetConversationsExecute(r ConversationsAPIGetConversationsRequest) (*TrackedConversations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackedConversations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.hasUnreadMessages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_unread_messages", r.hasUnreadMessages, "")
	}
	if r.listId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "list_id", r.listId, "")
	}
	if r.campaignId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "campaign_id", r.campaignId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConversationsAPIGetConversationsIdRequest struct {
	ctx context.Context
	ApiService ConversationsAPI
	conversationId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ConversationsAPIGetConversationsIdRequest) Fields(fields []string) ConversationsAPIGetConversationsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ConversationsAPIGetConversationsIdRequest) ExcludeFields(excludeFields []string) ConversationsAPIGetConversationsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ConversationsAPIGetConversationsIdRequest) Execute() (*Conversation, *http.Response, error) {
	return r.ApiService.GetConversationsIdExecute(r)
}

/*
GetConversationsId Get conversation

Get details about an individual conversation. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId The unique id for the conversation.
 @return ConversationsAPIGetConversationsIdRequest

Deprecated
*/
func (a *ConversationsAPIService) GetConversationsId(ctx context.Context, conversationId string) ConversationsAPIGetConversationsIdRequest {
	return ConversationsAPIGetConversationsIdRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return Conversation
// Deprecated
func (a *ConversationsAPIService) GetConversationsIdExecute(r ConversationsAPIGetConversationsIdRequest) (*Conversation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Conversation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/{conversation_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConversationsAPIGetConversationsIdMessagesRequest struct {
	ctx context.Context
	ApiService ConversationsAPI
	conversationId string
	fields *[]string
	excludeFields *[]string
	isRead *string
	beforeTimestamp *time.Time
	sinceTimestamp *time.Time
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ConversationsAPIGetConversationsIdMessagesRequest) Fields(fields []string) ConversationsAPIGetConversationsIdMessagesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ConversationsAPIGetConversationsIdMessagesRequest) ExcludeFields(excludeFields []string) ConversationsAPIGetConversationsIdMessagesRequest {
	r.excludeFields = &excludeFields
	return r
}

// Whether a conversation message has been marked as read.
func (r ConversationsAPIGetConversationsIdMessagesRequest) IsRead(isRead string) ConversationsAPIGetConversationsIdMessagesRequest {
	r.isRead = &isRead
	return r
}

// Restrict the response to messages created before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ConversationsAPIGetConversationsIdMessagesRequest) BeforeTimestamp(beforeTimestamp time.Time) ConversationsAPIGetConversationsIdMessagesRequest {
	r.beforeTimestamp = &beforeTimestamp
	return r
}

// Restrict the response to messages created after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ConversationsAPIGetConversationsIdMessagesRequest) SinceTimestamp(sinceTimestamp time.Time) ConversationsAPIGetConversationsIdMessagesRequest {
	r.sinceTimestamp = &sinceTimestamp
	return r
}

func (r ConversationsAPIGetConversationsIdMessagesRequest) Execute() (*CollectionOfConversationMessages, *http.Response, error) {
	return r.ApiService.GetConversationsIdMessagesExecute(r)
}

/*
GetConversationsIdMessages List messages

Get messages from a specific conversation. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId The unique id for the conversation.
 @return ConversationsAPIGetConversationsIdMessagesRequest

Deprecated
*/
func (a *ConversationsAPIService) GetConversationsIdMessages(ctx context.Context, conversationId string) ConversationsAPIGetConversationsIdMessagesRequest {
	return ConversationsAPIGetConversationsIdMessagesRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
	}
}

// Execute executes the request
//  @return CollectionOfConversationMessages
// Deprecated
func (a *ConversationsAPIService) GetConversationsIdMessagesExecute(r ConversationsAPIGetConversationsIdMessagesRequest) (*CollectionOfConversationMessages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfConversationMessages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsIdMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/{conversation_id}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.isRead != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_read", r.isRead, "")
	}
	if r.beforeTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_timestamp", r.beforeTimestamp, "")
	}
	if r.sinceTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_timestamp", r.sinceTimestamp, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ConversationsAPIGetConversationsIdMessagesIdRequest struct {
	ctx context.Context
	ApiService ConversationsAPI
	conversationId string
	messageId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ConversationsAPIGetConversationsIdMessagesIdRequest) Fields(fields []string) ConversationsAPIGetConversationsIdMessagesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ConversationsAPIGetConversationsIdMessagesIdRequest) ExcludeFields(excludeFields []string) ConversationsAPIGetConversationsIdMessagesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ConversationsAPIGetConversationsIdMessagesIdRequest) Execute() (*ConversationMessage, *http.Response, error) {
	return r.ApiService.GetConversationsIdMessagesIdExecute(r)
}

/*
GetConversationsIdMessagesId Get message

Get an individual message in a conversation. Conversations has been deprecated in favor of Inbox and these endpoints don't include Inbox data. Past Conversations are still available via this endpoint, but new campaign replies and other Inbox messages aren’t available using this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param conversationId The unique id for the conversation.
 @param messageId The unique id for the conversation message.
 @return ConversationsAPIGetConversationsIdMessagesIdRequest

Deprecated
*/
func (a *ConversationsAPIService) GetConversationsIdMessagesId(ctx context.Context, conversationId string, messageId string) ConversationsAPIGetConversationsIdMessagesIdRequest {
	return ConversationsAPIGetConversationsIdMessagesIdRequest{
		ApiService: a,
		ctx: ctx,
		conversationId: conversationId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return ConversationMessage
// Deprecated
func (a *ConversationsAPIService) GetConversationsIdMessagesIdExecute(r ConversationsAPIGetConversationsIdMessagesIdRequest) (*ConversationMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConversationMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsIdMessagesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/{conversation_id}/messages/{message_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"conversation_id"+"}", url.PathEscape(parameterValueToString(r.conversationId, "conversationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"message_id"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
