/*
Mailchimp Marketing API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.55
Contact: apihelp@mailchimp.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mailchimpmarketingapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type EcommerceAPI interface {

	/*
	DeleteEcommerceStoresId Delete store

	Delete a store. Deleting a store will also delete any associated subresources, including Customers, Orders, Products, and Carts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIDeleteEcommerceStoresIdRequest
	*/
	DeleteEcommerceStoresId(ctx context.Context, storeId string) EcommerceAPIDeleteEcommerceStoresIdRequest

	// DeleteEcommerceStoresIdExecute executes the request
	//  @return map[string]interface{}
	DeleteEcommerceStoresIdExecute(r EcommerceAPIDeleteEcommerceStoresIdRequest) (map[string]interface{}, *http.Response, error)

	/*
	DeleteEcommerceStoresIdCartsId Delete cart

	Delete a cart.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param cartId The id for the cart.
	@return EcommerceAPIDeleteEcommerceStoresIdCartsIdRequest
	*/
	DeleteEcommerceStoresIdCartsId(ctx context.Context, storeId string, cartId string) EcommerceAPIDeleteEcommerceStoresIdCartsIdRequest

	// DeleteEcommerceStoresIdCartsIdExecute executes the request
	DeleteEcommerceStoresIdCartsIdExecute(r EcommerceAPIDeleteEcommerceStoresIdCartsIdRequest) (*http.Response, error)

	/*
	DeleteEcommerceStoresIdCartsLinesId Delete cart line item

	Delete a specific cart line item.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param cartId The id for the cart.
	@param lineId The id for the line item of a cart.
	@return EcommerceAPIDeleteEcommerceStoresIdCartsLinesIdRequest
	*/
	DeleteEcommerceStoresIdCartsLinesId(ctx context.Context, storeId string, cartId string, lineId string) EcommerceAPIDeleteEcommerceStoresIdCartsLinesIdRequest

	// DeleteEcommerceStoresIdCartsLinesIdExecute executes the request
	DeleteEcommerceStoresIdCartsLinesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdCartsLinesIdRequest) (*http.Response, error)

	/*
	DeleteEcommerceStoresIdCustomersId Delete customer

	Delete a customer from a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param customerId The id for the customer of a store.
	@return EcommerceAPIDeleteEcommerceStoresIdCustomersIdRequest
	*/
	DeleteEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) EcommerceAPIDeleteEcommerceStoresIdCustomersIdRequest

	// DeleteEcommerceStoresIdCustomersIdExecute executes the request
	DeleteEcommerceStoresIdCustomersIdExecute(r EcommerceAPIDeleteEcommerceStoresIdCustomersIdRequest) (*http.Response, error)

	/*
	DeleteEcommerceStoresIdOrdersId Delete order

	Delete an order.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param orderId The id for the order in a store.
	@return EcommerceAPIDeleteEcommerceStoresIdOrdersIdRequest
	*/
	DeleteEcommerceStoresIdOrdersId(ctx context.Context, storeId string, orderId string) EcommerceAPIDeleteEcommerceStoresIdOrdersIdRequest

	// DeleteEcommerceStoresIdOrdersIdExecute executes the request
	DeleteEcommerceStoresIdOrdersIdExecute(r EcommerceAPIDeleteEcommerceStoresIdOrdersIdRequest) (*http.Response, error)

	/*
	DeleteEcommerceStoresIdOrdersIdLinesId Delete order line item

	Delete a specific order line item.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param orderId The id for the order in a store.
	@param lineId The id for the line item of an order.
	@return EcommerceAPIDeleteEcommerceStoresIdOrdersIdLinesIdRequest
	*/
	DeleteEcommerceStoresIdOrdersIdLinesId(ctx context.Context, storeId string, orderId string, lineId string) EcommerceAPIDeleteEcommerceStoresIdOrdersIdLinesIdRequest

	// DeleteEcommerceStoresIdOrdersIdLinesIdExecute executes the request
	DeleteEcommerceStoresIdOrdersIdLinesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdOrdersIdLinesIdRequest) (*http.Response, error)

	/*
	DeleteEcommerceStoresIdProductsId Delete product

	Delete a product.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@return EcommerceAPIDeleteEcommerceStoresIdProductsIdRequest
	*/
	DeleteEcommerceStoresIdProductsId(ctx context.Context, storeId string, productId string) EcommerceAPIDeleteEcommerceStoresIdProductsIdRequest

	// DeleteEcommerceStoresIdProductsIdExecute executes the request
	DeleteEcommerceStoresIdProductsIdExecute(r EcommerceAPIDeleteEcommerceStoresIdProductsIdRequest) (*http.Response, error)

	/*
	DeleteEcommerceStoresIdProductsIdImagesId Delete product image

	Delete a product image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@param imageId The id for the product image.
	@return EcommerceAPIDeleteEcommerceStoresIdProductsIdImagesIdRequest
	*/
	DeleteEcommerceStoresIdProductsIdImagesId(ctx context.Context, storeId string, productId string, imageId string) EcommerceAPIDeleteEcommerceStoresIdProductsIdImagesIdRequest

	// DeleteEcommerceStoresIdProductsIdImagesIdExecute executes the request
	DeleteEcommerceStoresIdProductsIdImagesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdProductsIdImagesIdRequest) (*http.Response, error)

	/*
	DeleteEcommerceStoresIdProductsIdVariantsId Delete product variant

	Delete a product variant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@param variantId The id for the product variant.
	@return EcommerceAPIDeleteEcommerceStoresIdProductsIdVariantsIdRequest
	*/
	DeleteEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) EcommerceAPIDeleteEcommerceStoresIdProductsIdVariantsIdRequest

	// DeleteEcommerceStoresIdProductsIdVariantsIdExecute executes the request
	DeleteEcommerceStoresIdProductsIdVariantsIdExecute(r EcommerceAPIDeleteEcommerceStoresIdProductsIdVariantsIdRequest) (*http.Response, error)

	/*
	DeleteEcommerceStoresIdPromocodesId Delete promo code

	Delete a promo code from a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param promoRuleId The id for the promo rule of a store.
	@param promoCodeId The id for the promo code of a store.
	@return EcommerceAPIDeleteEcommerceStoresIdPromocodesIdRequest
	*/
	DeleteEcommerceStoresIdPromocodesId(ctx context.Context, storeId string, promoRuleId string, promoCodeId string) EcommerceAPIDeleteEcommerceStoresIdPromocodesIdRequest

	// DeleteEcommerceStoresIdPromocodesIdExecute executes the request
	DeleteEcommerceStoresIdPromocodesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdPromocodesIdRequest) (*http.Response, error)

	/*
	DeleteEcommerceStoresIdPromorulesId Delete promo rule

	Delete a promo rule from a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param promoRuleId The id for the promo rule of a store.
	@return EcommerceAPIDeleteEcommerceStoresIdPromorulesIdRequest
	*/
	DeleteEcommerceStoresIdPromorulesId(ctx context.Context, storeId string, promoRuleId string) EcommerceAPIDeleteEcommerceStoresIdPromorulesIdRequest

	// DeleteEcommerceStoresIdPromorulesIdExecute executes the request
	DeleteEcommerceStoresIdPromorulesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdPromorulesIdRequest) (*http.Response, error)

	/*
	GetEcommerceOrders List account orders

	Get information about an account's orders.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return EcommerceAPIGetEcommerceOrdersRequest
	*/
	GetEcommerceOrders(ctx context.Context) EcommerceAPIGetEcommerceOrdersRequest

	// GetEcommerceOrdersExecute executes the request
	//  @return Orders
	GetEcommerceOrdersExecute(r EcommerceAPIGetEcommerceOrdersRequest) (*Orders, *http.Response, error)

	/*
	GetEcommerceStores List stores

	Get information about all stores in the account.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return EcommerceAPIGetEcommerceStoresRequest
	*/
	GetEcommerceStores(ctx context.Context) EcommerceAPIGetEcommerceStoresRequest

	// GetEcommerceStoresExecute executes the request
	//  @return ECommerceStores
	GetEcommerceStoresExecute(r EcommerceAPIGetEcommerceStoresRequest) (*ECommerceStores, *http.Response, error)

	/*
	GetEcommerceStoresId Get store info

	Get information about a specific store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIGetEcommerceStoresIdRequest
	*/
	GetEcommerceStoresId(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdRequest

	// GetEcommerceStoresIdExecute executes the request
	//  @return ECommerceStore
	GetEcommerceStoresIdExecute(r EcommerceAPIGetEcommerceStoresIdRequest) (*ECommerceStore, *http.Response, error)

	/*
	GetEcommerceStoresIdCarts List carts

	Get information about a store's carts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIGetEcommerceStoresIdCartsRequest
	*/
	GetEcommerceStoresIdCarts(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdCartsRequest

	// GetEcommerceStoresIdCartsExecute executes the request
	//  @return Carts
	GetEcommerceStoresIdCartsExecute(r EcommerceAPIGetEcommerceStoresIdCartsRequest) (*Carts, *http.Response, error)

	/*
	GetEcommerceStoresIdCartsId Get cart info

	Get information about a specific cart.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param cartId The id for the cart.
	@return EcommerceAPIGetEcommerceStoresIdCartsIdRequest
	*/
	GetEcommerceStoresIdCartsId(ctx context.Context, storeId string, cartId string) EcommerceAPIGetEcommerceStoresIdCartsIdRequest

	// GetEcommerceStoresIdCartsIdExecute executes the request
	//  @return ECommerceCart
	GetEcommerceStoresIdCartsIdExecute(r EcommerceAPIGetEcommerceStoresIdCartsIdRequest) (*ECommerceCart, *http.Response, error)

	/*
	GetEcommerceStoresIdCartsIdLines List cart line items

	Get information about a cart's line items.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param cartId The id for the cart.
	@return EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest
	*/
	GetEcommerceStoresIdCartsIdLines(ctx context.Context, storeId string, cartId string) EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest

	// GetEcommerceStoresIdCartsIdLinesExecute executes the request
	//  @return CartLines
	GetEcommerceStoresIdCartsIdLinesExecute(r EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest) (*CartLines, *http.Response, error)

	/*
	GetEcommerceStoresIdCartsIdLinesId Get cart line item

	Get information about a specific cart line item.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param cartId The id for the cart.
	@param lineId The id for the line item of a cart.
	@return EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest
	*/
	GetEcommerceStoresIdCartsIdLinesId(ctx context.Context, storeId string, cartId string, lineId string) EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest

	// GetEcommerceStoresIdCartsIdLinesIdExecute executes the request
	//  @return ECommerceCartLineItem
	GetEcommerceStoresIdCartsIdLinesIdExecute(r EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest) (*ECommerceCartLineItem, *http.Response, error)

	/*
	GetEcommerceStoresIdCustomers List customers

	Get information about a store's customers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIGetEcommerceStoresIdCustomersRequest
	*/
	GetEcommerceStoresIdCustomers(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdCustomersRequest

	// GetEcommerceStoresIdCustomersExecute executes the request
	//  @return Customers
	GetEcommerceStoresIdCustomersExecute(r EcommerceAPIGetEcommerceStoresIdCustomersRequest) (*Customers, *http.Response, error)

	/*
	GetEcommerceStoresIdCustomersId Get customer info

	Get information about a specific customer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param customerId The id for the customer of a store.
	@return EcommerceAPIGetEcommerceStoresIdCustomersIdRequest
	*/
	GetEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) EcommerceAPIGetEcommerceStoresIdCustomersIdRequest

	// GetEcommerceStoresIdCustomersIdExecute executes the request
	//  @return ECommerceCustomer
	GetEcommerceStoresIdCustomersIdExecute(r EcommerceAPIGetEcommerceStoresIdCustomersIdRequest) (*ECommerceCustomer, *http.Response, error)

	/*
	GetEcommerceStoresIdOrders List orders

	Get information about a store's orders.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIGetEcommerceStoresIdOrdersRequest
	*/
	GetEcommerceStoresIdOrders(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdOrdersRequest

	// GetEcommerceStoresIdOrdersExecute executes the request
	//  @return Orders1
	GetEcommerceStoresIdOrdersExecute(r EcommerceAPIGetEcommerceStoresIdOrdersRequest) (*Orders1, *http.Response, error)

	/*
	GetEcommerceStoresIdOrdersId Get order info

	Get information about a specific order.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param orderId The id for the order in a store.
	@return EcommerceAPIGetEcommerceStoresIdOrdersIdRequest
	*/
	GetEcommerceStoresIdOrdersId(ctx context.Context, storeId string, orderId string) EcommerceAPIGetEcommerceStoresIdOrdersIdRequest

	// GetEcommerceStoresIdOrdersIdExecute executes the request
	//  @return ECommerceOrder
	GetEcommerceStoresIdOrdersIdExecute(r EcommerceAPIGetEcommerceStoresIdOrdersIdRequest) (*ECommerceOrder, *http.Response, error)

	/*
	GetEcommerceStoresIdOrdersIdLines List order line items

	Get information about an order's line items.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param orderId The id for the order in a store.
	@return EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest
	*/
	GetEcommerceStoresIdOrdersIdLines(ctx context.Context, storeId string, orderId string) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest

	// GetEcommerceStoresIdOrdersIdLinesExecute executes the request
	//  @return OrderLines
	GetEcommerceStoresIdOrdersIdLinesExecute(r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest) (*OrderLines, *http.Response, error)

	/*
	GetEcommerceStoresIdOrdersIdLinesId Get order line item

	Get information about a specific order line item.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param orderId The id for the order in a store.
	@param lineId The id for the line item of an order.
	@return EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest
	*/
	GetEcommerceStoresIdOrdersIdLinesId(ctx context.Context, storeId string, orderId string, lineId string) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest

	// GetEcommerceStoresIdOrdersIdLinesIdExecute executes the request
	//  @return ECommerceOrderLineItem
	GetEcommerceStoresIdOrdersIdLinesIdExecute(r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest) (*ECommerceOrderLineItem, *http.Response, error)

	/*
	GetEcommerceStoresIdProducts List product

	Get information about a store's products.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIGetEcommerceStoresIdProductsRequest
	*/
	GetEcommerceStoresIdProducts(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdProductsRequest

	// GetEcommerceStoresIdProductsExecute executes the request
	//  @return Products
	GetEcommerceStoresIdProductsExecute(r EcommerceAPIGetEcommerceStoresIdProductsRequest) (*Products, *http.Response, error)

	/*
	GetEcommerceStoresIdProductsId Get product info

	Get information about a specific product.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@return EcommerceAPIGetEcommerceStoresIdProductsIdRequest
	*/
	GetEcommerceStoresIdProductsId(ctx context.Context, storeId string, productId string) EcommerceAPIGetEcommerceStoresIdProductsIdRequest

	// GetEcommerceStoresIdProductsIdExecute executes the request
	//  @return ECommerceProduct
	GetEcommerceStoresIdProductsIdExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdRequest) (*ECommerceProduct, *http.Response, error)

	/*
	GetEcommerceStoresIdProductsIdImages List product images

	Get information about a product's images.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@return EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest
	*/
	GetEcommerceStoresIdProductsIdImages(ctx context.Context, storeId string, productId string) EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest

	// GetEcommerceStoresIdProductsIdImagesExecute executes the request
	//  @return EcommerceProductImages
	GetEcommerceStoresIdProductsIdImagesExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest) (*EcommerceProductImages, *http.Response, error)

	/*
	GetEcommerceStoresIdProductsIdImagesId Get product image info

	Get information about a specific product image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@param imageId The id for the product image.
	@return EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest
	*/
	GetEcommerceStoresIdProductsIdImagesId(ctx context.Context, storeId string, productId string, imageId string) EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest

	// GetEcommerceStoresIdProductsIdImagesIdExecute executes the request
	//  @return ECommerceProductImage
	GetEcommerceStoresIdProductsIdImagesIdExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest) (*ECommerceProductImage, *http.Response, error)

	/*
	GetEcommerceStoresIdProductsIdVariants List product variants

	Get information about a product's variants.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@return EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest
	*/
	GetEcommerceStoresIdProductsIdVariants(ctx context.Context, storeId string, productId string) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest

	// GetEcommerceStoresIdProductsIdVariantsExecute executes the request
	//  @return EcommerceProductVariants
	GetEcommerceStoresIdProductsIdVariantsExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest) (*EcommerceProductVariants, *http.Response, error)

	/*
	GetEcommerceStoresIdProductsIdVariantsId Get product variant info

	Get information about a specific product variant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@param variantId The id for the product variant.
	@return EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest
	*/
	GetEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest

	// GetEcommerceStoresIdProductsIdVariantsIdExecute executes the request
	//  @return ECommerceProductVariant
	GetEcommerceStoresIdProductsIdVariantsIdExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest) (*ECommerceProductVariant, *http.Response, error)

	/*
	GetEcommerceStoresIdPromocodes List promo codes

	Get information about a store's promo codes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param promoRuleId The id for the promo rule of a store.
	@param storeId The store id.
	@return EcommerceAPIGetEcommerceStoresIdPromocodesRequest
	*/
	GetEcommerceStoresIdPromocodes(ctx context.Context, promoRuleId string, storeId string) EcommerceAPIGetEcommerceStoresIdPromocodesRequest

	// GetEcommerceStoresIdPromocodesExecute executes the request
	//  @return PromoCodes
	GetEcommerceStoresIdPromocodesExecute(r EcommerceAPIGetEcommerceStoresIdPromocodesRequest) (*PromoCodes, *http.Response, error)

	/*
	GetEcommerceStoresIdPromocodesId Get promo code

	Get information about a specific promo code.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param promoRuleId The id for the promo rule of a store.
	@param promoCodeId The id for the promo code of a store.
	@return EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest
	*/
	GetEcommerceStoresIdPromocodesId(ctx context.Context, storeId string, promoRuleId string, promoCodeId string) EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest

	// GetEcommerceStoresIdPromocodesIdExecute executes the request
	//  @return ECommercePromoCode
	GetEcommerceStoresIdPromocodesIdExecute(r EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest) (*ECommercePromoCode, *http.Response, error)

	/*
	GetEcommerceStoresIdPromorules List promo rules

	Get information about a store's promo rules.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIGetEcommerceStoresIdPromorulesRequest
	*/
	GetEcommerceStoresIdPromorules(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdPromorulesRequest

	// GetEcommerceStoresIdPromorulesExecute executes the request
	//  @return PromoRules
	GetEcommerceStoresIdPromorulesExecute(r EcommerceAPIGetEcommerceStoresIdPromorulesRequest) (*PromoRules, *http.Response, error)

	/*
	GetEcommerceStoresIdPromorulesId Get promo rule

	Get information about a specific promo rule.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param promoRuleId The id for the promo rule of a store.
	@return EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest
	*/
	GetEcommerceStoresIdPromorulesId(ctx context.Context, storeId string, promoRuleId string) EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest

	// GetEcommerceStoresIdPromorulesIdExecute executes the request
	//  @return ECommercePromoRule
	GetEcommerceStoresIdPromorulesIdExecute(r EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest) (*ECommercePromoRule, *http.Response, error)

	/*
	PatchEcommerceStoresId Update store

	Update a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIPatchEcommerceStoresIdRequest
	*/
	PatchEcommerceStoresId(ctx context.Context, storeId string) EcommerceAPIPatchEcommerceStoresIdRequest

	// PatchEcommerceStoresIdExecute executes the request
	//  @return ECommerceStore
	PatchEcommerceStoresIdExecute(r EcommerceAPIPatchEcommerceStoresIdRequest) (*ECommerceStore, *http.Response, error)

	/*
	PatchEcommerceStoresIdCartsId Update cart

	Update a specific cart.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param cartId The id for the cart.
	@return EcommerceAPIPatchEcommerceStoresIdCartsIdRequest
	*/
	PatchEcommerceStoresIdCartsId(ctx context.Context, storeId string, cartId string) EcommerceAPIPatchEcommerceStoresIdCartsIdRequest

	// PatchEcommerceStoresIdCartsIdExecute executes the request
	//  @return ECommerceCart
	PatchEcommerceStoresIdCartsIdExecute(r EcommerceAPIPatchEcommerceStoresIdCartsIdRequest) (*ECommerceCart, *http.Response, error)

	/*
	PatchEcommerceStoresIdCartsIdLinesId Update cart line item

	Update a specific cart line item.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param cartId The id for the cart.
	@param lineId The id for the line item of a cart.
	@return EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest
	*/
	PatchEcommerceStoresIdCartsIdLinesId(ctx context.Context, storeId string, cartId string, lineId string) EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest

	// PatchEcommerceStoresIdCartsIdLinesIdExecute executes the request
	//  @return ECommerceCartLineItem
	PatchEcommerceStoresIdCartsIdLinesIdExecute(r EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest) (*ECommerceCartLineItem, *http.Response, error)

	/*
	PatchEcommerceStoresIdCustomersId Update customer

	Update a customer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param customerId The id for the customer of a store.
	@return EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest
	*/
	PatchEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest

	// PatchEcommerceStoresIdCustomersIdExecute executes the request
	//  @return ECommerceCustomer
	PatchEcommerceStoresIdCustomersIdExecute(r EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest) (*ECommerceCustomer, *http.Response, error)

	/*
	PatchEcommerceStoresIdOrdersId Update order

	Update a specific order.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param orderId The id for the order in a store.
	@return EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest
	*/
	PatchEcommerceStoresIdOrdersId(ctx context.Context, storeId string, orderId string) EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest

	// PatchEcommerceStoresIdOrdersIdExecute executes the request
	//  @return ECommerceOrder
	PatchEcommerceStoresIdOrdersIdExecute(r EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest) (*ECommerceOrder, *http.Response, error)

	/*
	PatchEcommerceStoresIdOrdersIdLinesId Update order line item

	Update a specific order line item.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param orderId The id for the order in a store.
	@param lineId The id for the line item of an order.
	@return EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest
	*/
	PatchEcommerceStoresIdOrdersIdLinesId(ctx context.Context, storeId string, orderId string, lineId string) EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest

	// PatchEcommerceStoresIdOrdersIdLinesIdExecute executes the request
	//  @return ECommerceOrderLineItem
	PatchEcommerceStoresIdOrdersIdLinesIdExecute(r EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest) (*ECommerceOrderLineItem, *http.Response, error)

	/*
	PatchEcommerceStoresIdProductsId Update product

	Update a specific product.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@return EcommerceAPIPatchEcommerceStoresIdProductsIdRequest
	*/
	PatchEcommerceStoresIdProductsId(ctx context.Context, storeId string, productId string) EcommerceAPIPatchEcommerceStoresIdProductsIdRequest

	// PatchEcommerceStoresIdProductsIdExecute executes the request
	//  @return ECommerceProduct
	PatchEcommerceStoresIdProductsIdExecute(r EcommerceAPIPatchEcommerceStoresIdProductsIdRequest) (*ECommerceProduct, *http.Response, error)

	/*
	PatchEcommerceStoresIdProductsIdImagesId Update product image

	Update a product image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@param imageId The id for the product image.
	@return EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest
	*/
	PatchEcommerceStoresIdProductsIdImagesId(ctx context.Context, storeId string, productId string, imageId string) EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest

	// PatchEcommerceStoresIdProductsIdImagesIdExecute executes the request
	//  @return ECommerceProductImage
	PatchEcommerceStoresIdProductsIdImagesIdExecute(r EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest) (*ECommerceProductImage, *http.Response, error)

	/*
	PatchEcommerceStoresIdProductsIdVariantsId Update product variant

	Update a product variant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@param variantId The id for the product variant.
	@return EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest
	*/
	PatchEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest

	// PatchEcommerceStoresIdProductsIdVariantsIdExecute executes the request
	//  @return ECommerceProductVariant
	PatchEcommerceStoresIdProductsIdVariantsIdExecute(r EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest) (*ECommerceProductVariant, *http.Response, error)

	/*
	PatchEcommerceStoresIdPromocodesId Update promo code

	Update a promo code.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param promoRuleId The id for the promo rule of a store.
	@param promoCodeId The id for the promo code of a store.
	@return EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest
	*/
	PatchEcommerceStoresIdPromocodesId(ctx context.Context, storeId string, promoRuleId string, promoCodeId string) EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest

	// PatchEcommerceStoresIdPromocodesIdExecute executes the request
	//  @return ECommercePromoCode
	PatchEcommerceStoresIdPromocodesIdExecute(r EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest) (*ECommercePromoCode, *http.Response, error)

	/*
	PatchEcommerceStoresIdPromorulesId Update promo rule

	Update a promo rule.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param promoRuleId The id for the promo rule of a store.
	@return EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest
	*/
	PatchEcommerceStoresIdPromorulesId(ctx context.Context, storeId string, promoRuleId string) EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest

	// PatchEcommerceStoresIdPromorulesIdExecute executes the request
	//  @return ECommercePromoRule
	PatchEcommerceStoresIdPromorulesIdExecute(r EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest) (*ECommercePromoRule, *http.Response, error)

	/*
	PostEcommerceStores Add store

	Add a new store to your Mailchimp account.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return EcommerceAPIPostEcommerceStoresRequest
	*/
	PostEcommerceStores(ctx context.Context) EcommerceAPIPostEcommerceStoresRequest

	// PostEcommerceStoresExecute executes the request
	//  @return ECommerceStore
	PostEcommerceStoresExecute(r EcommerceAPIPostEcommerceStoresRequest) (*ECommerceStore, *http.Response, error)

	/*
	PostEcommerceStoresIdCarts Add cart

	Add a new cart to a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIPostEcommerceStoresIdCartsRequest
	*/
	PostEcommerceStoresIdCarts(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdCartsRequest

	// PostEcommerceStoresIdCartsExecute executes the request
	//  @return ECommerceCart
	PostEcommerceStoresIdCartsExecute(r EcommerceAPIPostEcommerceStoresIdCartsRequest) (*ECommerceCart, *http.Response, error)

	/*
	PostEcommerceStoresIdCartsIdLines Add cart line item

	Add a new line item to an existing cart.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param cartId The id for the cart.
	@return EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest
	*/
	PostEcommerceStoresIdCartsIdLines(ctx context.Context, storeId string, cartId string) EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest

	// PostEcommerceStoresIdCartsIdLinesExecute executes the request
	//  @return ECommerceCartLineItem
	PostEcommerceStoresIdCartsIdLinesExecute(r EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest) (*ECommerceCartLineItem, *http.Response, error)

	/*
	PostEcommerceStoresIdCustomers Add customer

	Add a new customer to a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIPostEcommerceStoresIdCustomersRequest
	*/
	PostEcommerceStoresIdCustomers(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdCustomersRequest

	// PostEcommerceStoresIdCustomersExecute executes the request
	//  @return ECommerceCustomer
	PostEcommerceStoresIdCustomersExecute(r EcommerceAPIPostEcommerceStoresIdCustomersRequest) (*ECommerceCustomer, *http.Response, error)

	/*
	PostEcommerceStoresIdOrders Add order

	Add a new order to a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIPostEcommerceStoresIdOrdersRequest
	*/
	PostEcommerceStoresIdOrders(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdOrdersRequest

	// PostEcommerceStoresIdOrdersExecute executes the request
	//  @return ECommerceOrder
	PostEcommerceStoresIdOrdersExecute(r EcommerceAPIPostEcommerceStoresIdOrdersRequest) (*ECommerceOrder, *http.Response, error)

	/*
	PostEcommerceStoresIdOrdersIdLines Add order line item

	Add a new line item to an existing order.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param orderId The id for the order in a store.
	@return EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest
	*/
	PostEcommerceStoresIdOrdersIdLines(ctx context.Context, storeId string, orderId string) EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest

	// PostEcommerceStoresIdOrdersIdLinesExecute executes the request
	//  @return ECommerceOrderLineItem
	PostEcommerceStoresIdOrdersIdLinesExecute(r EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest) (*ECommerceOrderLineItem, *http.Response, error)

	/*
	PostEcommerceStoresIdProducts Add product

	Add a new product to a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIPostEcommerceStoresIdProductsRequest
	*/
	PostEcommerceStoresIdProducts(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdProductsRequest

	// PostEcommerceStoresIdProductsExecute executes the request
	//  @return ECommerceProduct
	PostEcommerceStoresIdProductsExecute(r EcommerceAPIPostEcommerceStoresIdProductsRequest) (*ECommerceProduct, *http.Response, error)

	/*
	PostEcommerceStoresIdProductsIdImages Add product image

	Add a new image to the product.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@return EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest
	*/
	PostEcommerceStoresIdProductsIdImages(ctx context.Context, storeId string, productId string) EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest

	// PostEcommerceStoresIdProductsIdImagesExecute executes the request
	//  @return ECommerceProductImage
	PostEcommerceStoresIdProductsIdImagesExecute(r EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest) (*ECommerceProductImage, *http.Response, error)

	/*
	PostEcommerceStoresIdProductsIdVariants Add product variant

	Add a new variant to the product.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@return EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest
	*/
	PostEcommerceStoresIdProductsIdVariants(ctx context.Context, storeId string, productId string) EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest

	// PostEcommerceStoresIdProductsIdVariantsExecute executes the request
	//  @return ECommerceProductVariant
	PostEcommerceStoresIdProductsIdVariantsExecute(r EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest) (*ECommerceProductVariant, *http.Response, error)

	/*
	PostEcommerceStoresIdPromocodes Add promo code

	Add a new promo code to a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param promoRuleId The id for the promo rule of a store.
	@return EcommerceAPIPostEcommerceStoresIdPromocodesRequest
	*/
	PostEcommerceStoresIdPromocodes(ctx context.Context, storeId string, promoRuleId string) EcommerceAPIPostEcommerceStoresIdPromocodesRequest

	// PostEcommerceStoresIdPromocodesExecute executes the request
	//  @return ECommercePromoCode
	PostEcommerceStoresIdPromocodesExecute(r EcommerceAPIPostEcommerceStoresIdPromocodesRequest) (*ECommercePromoCode, *http.Response, error)

	/*
	PostEcommerceStoresIdPromorules Add promo rule

	Add a new promo rule to a store.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@return EcommerceAPIPostEcommerceStoresIdPromorulesRequest
	*/
	PostEcommerceStoresIdPromorules(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdPromorulesRequest

	// PostEcommerceStoresIdPromorulesExecute executes the request
	//  @return ECommercePromoRule
	PostEcommerceStoresIdPromorulesExecute(r EcommerceAPIPostEcommerceStoresIdPromorulesRequest) (*ECommercePromoRule, *http.Response, error)

	/*
	PutEcommerceStoresIdCustomersId Add or update customer

	Add or update a customer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param customerId The id for the customer of a store.
	@return EcommerceAPIPutEcommerceStoresIdCustomersIdRequest
	*/
	PutEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) EcommerceAPIPutEcommerceStoresIdCustomersIdRequest

	// PutEcommerceStoresIdCustomersIdExecute executes the request
	//  @return ECommerceCustomer
	PutEcommerceStoresIdCustomersIdExecute(r EcommerceAPIPutEcommerceStoresIdCustomersIdRequest) (*ECommerceCustomer, *http.Response, error)

	/*
	PutEcommerceStoresIdProductsIdVariantsId Add or update product variant

	Add or update a product variant.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param storeId The store id.
	@param productId The id for the product of a store.
	@param variantId The id for the product variant.
	@return EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest
	*/
	PutEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest

	// PutEcommerceStoresIdProductsIdVariantsIdExecute executes the request
	//  @return ECommerceProductVariant
	PutEcommerceStoresIdProductsIdVariantsIdExecute(r EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest) (*ECommerceProductVariant, *http.Response, error)
}

// EcommerceAPIService EcommerceAPI service
type EcommerceAPIService service

type EcommerceAPIDeleteEcommerceStoresIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdExecute(r)
}

/*
DeleteEcommerceStoresId Delete store

Delete a store. Deleting a store will also delete any associated subresources, including Customers, Orders, Products, and Carts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIDeleteEcommerceStoresIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresId(ctx context.Context, storeId string) EcommerceAPIDeleteEcommerceStoresIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EcommerceAPIService) DeleteEcommerceStoresIdExecute(r EcommerceAPIDeleteEcommerceStoresIdRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdCartsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	cartId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdCartsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdCartsIdExecute(r)
}

/*
DeleteEcommerceStoresIdCartsId Delete cart

Delete a cart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return EcommerceAPIDeleteEcommerceStoresIdCartsIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCartsId(ctx context.Context, storeId string, cartId string) EcommerceAPIDeleteEcommerceStoresIdCartsIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdCartsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCartsIdExecute(r EcommerceAPIDeleteEcommerceStoresIdCartsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdCartsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdCartsLinesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	cartId string
	lineId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdCartsLinesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdCartsLinesIdExecute(r)
}

/*
DeleteEcommerceStoresIdCartsLinesId Delete cart line item

Delete a specific cart line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @param lineId The id for the line item of a cart.
 @return EcommerceAPIDeleteEcommerceStoresIdCartsLinesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCartsLinesId(ctx context.Context, storeId string, cartId string, lineId string) EcommerceAPIDeleteEcommerceStoresIdCartsLinesIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdCartsLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
		lineId: lineId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCartsLinesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdCartsLinesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdCartsLinesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdCustomersIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	customerId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdCustomersIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdCustomersIdExecute(r)
}

/*
DeleteEcommerceStoresIdCustomersId Delete customer

Delete a customer from a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param customerId The id for the customer of a store.
 @return EcommerceAPIDeleteEcommerceStoresIdCustomersIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) EcommerceAPIDeleteEcommerceStoresIdCustomersIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdCustomersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		customerId: customerId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdCustomersIdExecute(r EcommerceAPIDeleteEcommerceStoresIdCustomersIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdCustomersId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers/{customer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customer_id"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdOrdersIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	orderId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdOrdersIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdOrdersIdExecute(r)
}

/*
DeleteEcommerceStoresIdOrdersId Delete order

Delete an order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return EcommerceAPIDeleteEcommerceStoresIdOrdersIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdOrdersId(ctx context.Context, storeId string, orderId string) EcommerceAPIDeleteEcommerceStoresIdOrdersIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdOrdersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdOrdersIdExecute(r EcommerceAPIDeleteEcommerceStoresIdOrdersIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdOrdersId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdOrdersIdLinesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	orderId string
	lineId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdOrdersIdLinesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdOrdersIdLinesIdExecute(r)
}

/*
DeleteEcommerceStoresIdOrdersIdLinesId Delete order line item

Delete a specific order line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @param lineId The id for the line item of an order.
 @return EcommerceAPIDeleteEcommerceStoresIdOrdersIdLinesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdOrdersIdLinesId(ctx context.Context, storeId string, orderId string, lineId string) EcommerceAPIDeleteEcommerceStoresIdOrdersIdLinesIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdOrdersIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
		lineId: lineId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdOrdersIdLinesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdOrdersIdLinesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdOrdersIdLinesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdProductsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdProductsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdProductsIdExecute(r)
}

/*
DeleteEcommerceStoresIdProductsId Delete product

Delete a product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return EcommerceAPIDeleteEcommerceStoresIdProductsIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsId(ctx context.Context, storeId string, productId string) EcommerceAPIDeleteEcommerceStoresIdProductsIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdProductsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdExecute(r EcommerceAPIDeleteEcommerceStoresIdProductsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdProductsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdProductsIdImagesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	imageId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdProductsIdImagesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdProductsIdImagesIdExecute(r)
}

/*
DeleteEcommerceStoresIdProductsIdImagesId Delete product image

Delete a product image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param imageId The id for the product image.
 @return EcommerceAPIDeleteEcommerceStoresIdProductsIdImagesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdImagesId(ctx context.Context, storeId string, productId string, imageId string) EcommerceAPIDeleteEcommerceStoresIdProductsIdImagesIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdProductsIdImagesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		imageId: imageId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdImagesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdProductsIdImagesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdProductsIdImagesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images/{image_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"image_id"+"}", url.PathEscape(parameterValueToString(r.imageId, "imageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdProductsIdVariantsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	variantId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdProductsIdVariantsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdProductsIdVariantsIdExecute(r)
}

/*
DeleteEcommerceStoresIdProductsIdVariantsId Delete product variant

Delete a product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param variantId The id for the product variant.
 @return EcommerceAPIDeleteEcommerceStoresIdProductsIdVariantsIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) EcommerceAPIDeleteEcommerceStoresIdProductsIdVariantsIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdProductsIdVariantsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		variantId: variantId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdProductsIdVariantsIdExecute(r EcommerceAPIDeleteEcommerceStoresIdProductsIdVariantsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdProductsIdVariantsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants/{variant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variant_id"+"}", url.PathEscape(parameterValueToString(r.variantId, "variantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdPromocodesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	promoRuleId string
	promoCodeId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdPromocodesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdPromocodesIdExecute(r)
}

/*
DeleteEcommerceStoresIdPromocodesId Delete promo code

Delete a promo code from a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @param promoCodeId The id for the promo code of a store.
 @return EcommerceAPIDeleteEcommerceStoresIdPromocodesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdPromocodesId(ctx context.Context, storeId string, promoRuleId string, promoCodeId string) EcommerceAPIDeleteEcommerceStoresIdPromocodesIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdPromocodesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
		promoCodeId: promoCodeId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdPromocodesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdPromocodesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdPromocodesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes/{promo_code_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_code_id"+"}", url.PathEscape(parameterValueToString(r.promoCodeId, "promoCodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIDeleteEcommerceStoresIdPromorulesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	promoRuleId string
}

func (r EcommerceAPIDeleteEcommerceStoresIdPromorulesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEcommerceStoresIdPromorulesIdExecute(r)
}

/*
DeleteEcommerceStoresIdPromorulesId Delete promo rule

Delete a promo rule from a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @return EcommerceAPIDeleteEcommerceStoresIdPromorulesIdRequest
*/
func (a *EcommerceAPIService) DeleteEcommerceStoresIdPromorulesId(ctx context.Context, storeId string, promoRuleId string) EcommerceAPIDeleteEcommerceStoresIdPromorulesIdRequest {
	return EcommerceAPIDeleteEcommerceStoresIdPromorulesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
	}
}

// Execute executes the request
func (a *EcommerceAPIService) DeleteEcommerceStoresIdPromorulesIdExecute(r EcommerceAPIDeleteEcommerceStoresIdPromorulesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.DeleteEcommerceStoresIdPromorulesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceOrdersRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	campaignId *string
	outreachId *string
	customerId *string
	hasOutreach *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceOrdersRequest) Fields(fields []string) EcommerceAPIGetEcommerceOrdersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceOrdersRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceOrdersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceOrdersRequest) Count(count int32) EcommerceAPIGetEcommerceOrdersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceOrdersRequest) Offset(offset int32) EcommerceAPIGetEcommerceOrdersRequest {
	r.offset = &offset
	return r
}

// Restrict results to orders with a specific &#x60;campaign_id&#x60; value.
func (r EcommerceAPIGetEcommerceOrdersRequest) CampaignId(campaignId string) EcommerceAPIGetEcommerceOrdersRequest {
	r.campaignId = &campaignId
	return r
}

// Restrict results to orders with a specific &#x60;outreach_id&#x60; value.
func (r EcommerceAPIGetEcommerceOrdersRequest) OutreachId(outreachId string) EcommerceAPIGetEcommerceOrdersRequest {
	r.outreachId = &outreachId
	return r
}

// Restrict results to orders made by a specific customer.
func (r EcommerceAPIGetEcommerceOrdersRequest) CustomerId(customerId string) EcommerceAPIGetEcommerceOrdersRequest {
	r.customerId = &customerId
	return r
}

// Restrict results to orders that have an outreach attached. For example, an email campaign or Facebook ad.
func (r EcommerceAPIGetEcommerceOrdersRequest) HasOutreach(hasOutreach bool) EcommerceAPIGetEcommerceOrdersRequest {
	r.hasOutreach = &hasOutreach
	return r
}

func (r EcommerceAPIGetEcommerceOrdersRequest) Execute() (*Orders, *http.Response, error) {
	return r.ApiService.GetEcommerceOrdersExecute(r)
}

/*
GetEcommerceOrders List account orders

Get information about an account's orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EcommerceAPIGetEcommerceOrdersRequest
*/
func (a *EcommerceAPIService) GetEcommerceOrders(ctx context.Context) EcommerceAPIGetEcommerceOrdersRequest {
	return EcommerceAPIGetEcommerceOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Orders
func (a *EcommerceAPIService) GetEcommerceOrdersExecute(r EcommerceAPIGetEcommerceOrdersRequest) (*Orders, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Orders
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.campaignId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "campaign_id", r.campaignId, "")
	}
	if r.outreachId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outreach_id", r.outreachId, "")
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_id", r.customerId, "")
	}
	if r.hasOutreach != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_outreach", r.hasOutreach, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresRequest) Count(count int32) EcommerceAPIGetEcommerceStoresRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresRequest {
	r.offset = &offset
	return r
}

func (r EcommerceAPIGetEcommerceStoresRequest) Execute() (*ECommerceStores, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresExecute(r)
}

/*
GetEcommerceStores List stores

Get information about all stores in the account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EcommerceAPIGetEcommerceStoresRequest
*/
func (a *EcommerceAPIService) GetEcommerceStores(ctx context.Context) EcommerceAPIGetEcommerceStoresRequest {
	return EcommerceAPIGetEcommerceStoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ECommerceStores
func (a *EcommerceAPIService) GetEcommerceStoresExecute(r EcommerceAPIGetEcommerceStoresRequest) (*ECommerceStores, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceStores
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdRequest) Execute() (*ECommerceStore, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdExecute(r)
}

/*
GetEcommerceStoresId Get store info

Get information about a specific store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIGetEcommerceStoresIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresId(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdRequest {
	return EcommerceAPIGetEcommerceStoresIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceStore
func (a *EcommerceAPIService) GetEcommerceStoresIdExecute(r EcommerceAPIGetEcommerceStoresIdRequest) (*ECommerceStore, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdCartsRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCartsRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdCartsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCartsRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdCartsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdCartsRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdCartsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdCartsRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdCartsRequest {
	r.offset = &offset
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdCartsRequest) Execute() (*Carts, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCartsExecute(r)
}

/*
GetEcommerceStoresIdCarts List carts

Get information about a store's carts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIGetEcommerceStoresIdCartsRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCarts(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdCartsRequest {
	return EcommerceAPIGetEcommerceStoresIdCartsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return Carts
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsExecute(r EcommerceAPIGetEcommerceStoresIdCartsRequest) (*Carts, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Carts
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCarts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdCartsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	cartId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCartsIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdCartsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCartsIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdCartsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdCartsIdRequest) Execute() (*ECommerceCart, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCartsIdExecute(r)
}

/*
GetEcommerceStoresIdCartsId Get cart info

Get information about a specific cart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return EcommerceAPIGetEcommerceStoresIdCartsIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsId(ctx context.Context, storeId string, cartId string) EcommerceAPIGetEcommerceStoresIdCartsIdRequest {
	return EcommerceAPIGetEcommerceStoresIdCartsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
//  @return ECommerceCart
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdExecute(r EcommerceAPIGetEcommerceStoresIdCartsIdRequest) (*ECommerceCart, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCart
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCartsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	cartId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest {
	r.offset = &offset
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest) Execute() (*CartLines, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCartsIdLinesExecute(r)
}

/*
GetEcommerceStoresIdCartsIdLines List cart line items

Get information about a cart's line items.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdLines(ctx context.Context, storeId string, cartId string) EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest {
	return EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
//  @return CartLines
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdLinesExecute(r EcommerceAPIGetEcommerceStoresIdCartsIdLinesRequest) (*CartLines, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CartLines
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCartsIdLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	cartId string
	lineId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest) Execute() (*ECommerceCartLineItem, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCartsIdLinesIdExecute(r)
}

/*
GetEcommerceStoresIdCartsIdLinesId Get cart line item

Get information about a specific cart line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @param lineId The id for the line item of a cart.
 @return EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdLinesId(ctx context.Context, storeId string, cartId string, lineId string) EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest {
	return EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
		lineId: lineId,
	}
}

// Execute executes the request
//  @return ECommerceCartLineItem
func (a *EcommerceAPIService) GetEcommerceStoresIdCartsIdLinesIdExecute(r EcommerceAPIGetEcommerceStoresIdCartsIdLinesIdRequest) (*ECommerceCartLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCartLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCartsIdLinesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdCustomersRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	emailAddress *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCustomersRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdCustomersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCustomersRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdCustomersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdCustomersRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdCustomersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdCustomersRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdCustomersRequest {
	r.offset = &offset
	return r
}

// Restrict the response to customers with the email address.
func (r EcommerceAPIGetEcommerceStoresIdCustomersRequest) EmailAddress(emailAddress string) EcommerceAPIGetEcommerceStoresIdCustomersRequest {
	r.emailAddress = &emailAddress
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdCustomersRequest) Execute() (*Customers, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCustomersExecute(r)
}

/*
GetEcommerceStoresIdCustomers List customers

Get information about a store's customers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIGetEcommerceStoresIdCustomersRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCustomers(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdCustomersRequest {
	return EcommerceAPIGetEcommerceStoresIdCustomersRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return Customers
func (a *EcommerceAPIService) GetEcommerceStoresIdCustomersExecute(r EcommerceAPIGetEcommerceStoresIdCustomersRequest) (*Customers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Customers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCustomers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.emailAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email_address", r.emailAddress, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdCustomersIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	customerId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCustomersIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdCustomersIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdCustomersIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdCustomersIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdCustomersIdRequest) Execute() (*ECommerceCustomer, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdCustomersIdExecute(r)
}

/*
GetEcommerceStoresIdCustomersId Get customer info

Get information about a specific customer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param customerId The id for the customer of a store.
 @return EcommerceAPIGetEcommerceStoresIdCustomersIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) EcommerceAPIGetEcommerceStoresIdCustomersIdRequest {
	return EcommerceAPIGetEcommerceStoresIdCustomersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		customerId: customerId,
	}
}

// Execute executes the request
//  @return ECommerceCustomer
func (a *EcommerceAPIService) GetEcommerceStoresIdCustomersIdExecute(r EcommerceAPIGetEcommerceStoresIdCustomersIdRequest) (*ECommerceCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdCustomersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers/{customer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customer_id"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdOrdersRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	customerId *string
	hasOutreach *bool
	campaignId *string
	outreachId *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdOrdersRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdOrdersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdOrdersRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdOrdersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdOrdersRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdOrdersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdOrdersRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdOrdersRequest {
	r.offset = &offset
	return r
}

// Restrict results to orders made by a specific customer.
func (r EcommerceAPIGetEcommerceStoresIdOrdersRequest) CustomerId(customerId string) EcommerceAPIGetEcommerceStoresIdOrdersRequest {
	r.customerId = &customerId
	return r
}

// Restrict results to orders that have an outreach attached. For example, an email campaign or Facebook ad.
func (r EcommerceAPIGetEcommerceStoresIdOrdersRequest) HasOutreach(hasOutreach bool) EcommerceAPIGetEcommerceStoresIdOrdersRequest {
	r.hasOutreach = &hasOutreach
	return r
}

// Restrict results to orders with a specific &#x60;campaign_id&#x60; value.
func (r EcommerceAPIGetEcommerceStoresIdOrdersRequest) CampaignId(campaignId string) EcommerceAPIGetEcommerceStoresIdOrdersRequest {
	r.campaignId = &campaignId
	return r
}

// Restrict results to orders with a specific &#x60;outreach_id&#x60; value.
func (r EcommerceAPIGetEcommerceStoresIdOrdersRequest) OutreachId(outreachId string) EcommerceAPIGetEcommerceStoresIdOrdersRequest {
	r.outreachId = &outreachId
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdOrdersRequest) Execute() (*Orders1, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdOrdersExecute(r)
}

/*
GetEcommerceStoresIdOrders List orders

Get information about a store's orders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIGetEcommerceStoresIdOrdersRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdOrders(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdOrdersRequest {
	return EcommerceAPIGetEcommerceStoresIdOrdersRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return Orders1
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersExecute(r EcommerceAPIGetEcommerceStoresIdOrdersRequest) (*Orders1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Orders1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_id", r.customerId, "")
	}
	if r.hasOutreach != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_outreach", r.hasOutreach, "")
	}
	if r.campaignId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "campaign_id", r.campaignId, "")
	}
	if r.outreachId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outreach_id", r.outreachId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdOrdersIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	orderId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdOrdersIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdOrdersIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdOrdersIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdOrdersIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdOrdersIdRequest) Execute() (*ECommerceOrder, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdOrdersIdExecute(r)
}

/*
GetEcommerceStoresIdOrdersId Get order info

Get information about a specific order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return EcommerceAPIGetEcommerceStoresIdOrdersIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersId(ctx context.Context, storeId string, orderId string) EcommerceAPIGetEcommerceStoresIdOrdersIdRequest {
	return EcommerceAPIGetEcommerceStoresIdOrdersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return ECommerceOrder
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdExecute(r EcommerceAPIGetEcommerceStoresIdOrdersIdRequest) (*ECommerceOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdOrdersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	orderId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest {
	r.offset = &offset
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest) Execute() (*OrderLines, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdOrdersIdLinesExecute(r)
}

/*
GetEcommerceStoresIdOrdersIdLines List order line items

Get information about an order's line items.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdLines(ctx context.Context, storeId string, orderId string) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest {
	return EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return OrderLines
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdLinesExecute(r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesRequest) (*OrderLines, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderLines
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdOrdersIdLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	orderId string
	lineId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest) Execute() (*ECommerceOrderLineItem, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdOrdersIdLinesIdExecute(r)
}

/*
GetEcommerceStoresIdOrdersIdLinesId Get order line item

Get information about a specific order line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @param lineId The id for the line item of an order.
 @return EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdLinesId(ctx context.Context, storeId string, orderId string, lineId string) EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest {
	return EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
		lineId: lineId,
	}
}

// Execute executes the request
//  @return ECommerceOrderLineItem
func (a *EcommerceAPIService) GetEcommerceStoresIdOrdersIdLinesIdExecute(r EcommerceAPIGetEcommerceStoresIdOrdersIdLinesIdRequest) (*ECommerceOrderLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrderLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdOrdersIdLinesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdProductsRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdProductsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdProductsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdProductsRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdProductsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdProductsRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdProductsRequest {
	r.offset = &offset
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdProductsRequest) Execute() (*Products, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsExecute(r)
}

/*
GetEcommerceStoresIdProducts List product

Get information about a store's products.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIGetEcommerceStoresIdProductsRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProducts(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdProductsRequest {
	return EcommerceAPIGetEcommerceStoresIdProductsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return Products
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsExecute(r EcommerceAPIGetEcommerceStoresIdProductsRequest) (*Products, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Products
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProducts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdProductsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdProductsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdProductsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdProductsIdRequest) Execute() (*ECommerceProduct, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdExecute(r)
}

/*
GetEcommerceStoresIdProductsId Get product info

Get information about a specific product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return EcommerceAPIGetEcommerceStoresIdProductsIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsId(ctx context.Context, storeId string, productId string) EcommerceAPIGetEcommerceStoresIdProductsIdRequest {
	return EcommerceAPIGetEcommerceStoresIdProductsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ECommerceProduct
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdRequest) (*ECommerceProduct, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProduct
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest {
	r.offset = &offset
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest) Execute() (*EcommerceProductImages, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdImagesExecute(r)
}

/*
GetEcommerceStoresIdProductsIdImages List product images

Get information about a product's images.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdImages(ctx context.Context, storeId string, productId string) EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest {
	return EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return EcommerceProductImages
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdImagesExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdImagesRequest) (*EcommerceProductImages, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EcommerceProductImages
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsIdImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	imageId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest) Execute() (*ECommerceProductImage, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdImagesIdExecute(r)
}

/*
GetEcommerceStoresIdProductsIdImagesId Get product image info

Get information about a specific product image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param imageId The id for the product image.
 @return EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdImagesId(ctx context.Context, storeId string, productId string, imageId string) EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest {
	return EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		imageId: imageId,
	}
}

// Execute executes the request
//  @return ECommerceProductImage
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdImagesIdExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdImagesIdRequest) (*ECommerceProductImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsIdImagesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images/{image_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"image_id"+"}", url.PathEscape(parameterValueToString(r.imageId, "imageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest {
	r.offset = &offset
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest) Execute() (*EcommerceProductVariants, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdVariantsExecute(r)
}

/*
GetEcommerceStoresIdProductsIdVariants List product variants

Get information about a product's variants.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdVariants(ctx context.Context, storeId string, productId string) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest {
	return EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return EcommerceProductVariants
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdVariantsExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsRequest) (*EcommerceProductVariants, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EcommerceProductVariants
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsIdVariants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	variantId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest) Execute() (*ECommerceProductVariant, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdProductsIdVariantsIdExecute(r)
}

/*
GetEcommerceStoresIdProductsIdVariantsId Get product variant info

Get information about a specific product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param variantId The id for the product variant.
 @return EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest {
	return EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		variantId: variantId,
	}
}

// Execute executes the request
//  @return ECommerceProductVariant
func (a *EcommerceAPIService) GetEcommerceStoresIdProductsIdVariantsIdExecute(r EcommerceAPIGetEcommerceStoresIdProductsIdVariantsIdRequest) (*ECommerceProductVariant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductVariant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdProductsIdVariantsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants/{variant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variant_id"+"}", url.PathEscape(parameterValueToString(r.variantId, "variantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdPromocodesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	promoRuleId string
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdPromocodesRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdPromocodesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdPromocodesRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdPromocodesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdPromocodesRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdPromocodesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdPromocodesRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdPromocodesRequest {
	r.offset = &offset
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdPromocodesRequest) Execute() (*PromoCodes, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdPromocodesExecute(r)
}

/*
GetEcommerceStoresIdPromocodes List promo codes

Get information about a store's promo codes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param promoRuleId The id for the promo rule of a store.
 @param storeId The store id.
 @return EcommerceAPIGetEcommerceStoresIdPromocodesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdPromocodes(ctx context.Context, promoRuleId string, storeId string) EcommerceAPIGetEcommerceStoresIdPromocodesRequest {
	return EcommerceAPIGetEcommerceStoresIdPromocodesRequest{
		ApiService: a,
		ctx: ctx,
		promoRuleId: promoRuleId,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return PromoCodes
func (a *EcommerceAPIService) GetEcommerceStoresIdPromocodesExecute(r EcommerceAPIGetEcommerceStoresIdPromocodesRequest) (*PromoCodes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromoCodes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdPromocodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes"
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	promoRuleId string
	promoCodeId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest) Execute() (*ECommercePromoCode, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdPromocodesIdExecute(r)
}

/*
GetEcommerceStoresIdPromocodesId Get promo code

Get information about a specific promo code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @param promoCodeId The id for the promo code of a store.
 @return EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdPromocodesId(ctx context.Context, storeId string, promoRuleId string, promoCodeId string) EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest {
	return EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
		promoCodeId: promoCodeId,
	}
}

// Execute executes the request
//  @return ECommercePromoCode
func (a *EcommerceAPIService) GetEcommerceStoresIdPromocodesIdExecute(r EcommerceAPIGetEcommerceStoresIdPromocodesIdRequest) (*ECommercePromoCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdPromocodesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes/{promo_code_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_code_id"+"}", url.PathEscape(parameterValueToString(r.promoCodeId, "promoCodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdPromorulesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdPromorulesRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdPromorulesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdPromorulesRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdPromorulesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r EcommerceAPIGetEcommerceStoresIdPromorulesRequest) Count(count int32) EcommerceAPIGetEcommerceStoresIdPromorulesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r EcommerceAPIGetEcommerceStoresIdPromorulesRequest) Offset(offset int32) EcommerceAPIGetEcommerceStoresIdPromorulesRequest {
	r.offset = &offset
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdPromorulesRequest) Execute() (*PromoRules, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdPromorulesExecute(r)
}

/*
GetEcommerceStoresIdPromorules List promo rules

Get information about a store's promo rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIGetEcommerceStoresIdPromorulesRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdPromorules(ctx context.Context, storeId string) EcommerceAPIGetEcommerceStoresIdPromorulesRequest {
	return EcommerceAPIGetEcommerceStoresIdPromorulesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return PromoRules
func (a *EcommerceAPIService) GetEcommerceStoresIdPromorulesExecute(r EcommerceAPIGetEcommerceStoresIdPromorulesRequest) (*PromoRules, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PromoRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdPromorules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	promoRuleId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest) Fields(fields []string) EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest) ExcludeFields(excludeFields []string) EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest) Execute() (*ECommercePromoRule, *http.Response, error) {
	return r.ApiService.GetEcommerceStoresIdPromorulesIdExecute(r)
}

/*
GetEcommerceStoresIdPromorulesId Get promo rule

Get information about a specific promo rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @return EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest
*/
func (a *EcommerceAPIService) GetEcommerceStoresIdPromorulesId(ctx context.Context, storeId string, promoRuleId string) EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest {
	return EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
	}
}

// Execute executes the request
//  @return ECommercePromoRule
func (a *EcommerceAPIService) GetEcommerceStoresIdPromorulesIdExecute(r EcommerceAPIGetEcommerceStoresIdPromorulesIdRequest) (*ECommercePromoRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.GetEcommerceStoresIdPromorulesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	body *ECommerceStore2
}

func (r EcommerceAPIPatchEcommerceStoresIdRequest) Body(body ECommerceStore2) EcommerceAPIPatchEcommerceStoresIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdRequest) Execute() (*ECommerceStore, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdExecute(r)
}

/*
PatchEcommerceStoresId Update store

Update a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIPatchEcommerceStoresIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresId(ctx context.Context, storeId string) EcommerceAPIPatchEcommerceStoresIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceStore
func (a *EcommerceAPIService) PatchEcommerceStoresIdExecute(r EcommerceAPIPatchEcommerceStoresIdRequest) (*ECommerceStore, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdCartsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	cartId string
	body *ECommerceCart2
}

func (r EcommerceAPIPatchEcommerceStoresIdCartsIdRequest) Body(body ECommerceCart2) EcommerceAPIPatchEcommerceStoresIdCartsIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdCartsIdRequest) Execute() (*ECommerceCart, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdCartsIdExecute(r)
}

/*
PatchEcommerceStoresIdCartsId Update cart

Update a specific cart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return EcommerceAPIPatchEcommerceStoresIdCartsIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdCartsId(ctx context.Context, storeId string, cartId string) EcommerceAPIPatchEcommerceStoresIdCartsIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdCartsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
//  @return ECommerceCart
func (a *EcommerceAPIService) PatchEcommerceStoresIdCartsIdExecute(r EcommerceAPIPatchEcommerceStoresIdCartsIdRequest) (*ECommerceCart, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCart
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdCartsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	cartId string
	lineId string
	body *ECommerceCartLineItem2
}

func (r EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest) Body(body ECommerceCartLineItem2) EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest) Execute() (*ECommerceCartLineItem, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdCartsIdLinesIdExecute(r)
}

/*
PatchEcommerceStoresIdCartsIdLinesId Update cart line item

Update a specific cart line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @param lineId The id for the line item of a cart.
 @return EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdCartsIdLinesId(ctx context.Context, storeId string, cartId string, lineId string) EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
		lineId: lineId,
	}
}

// Execute executes the request
//  @return ECommerceCartLineItem
func (a *EcommerceAPIService) PatchEcommerceStoresIdCartsIdLinesIdExecute(r EcommerceAPIPatchEcommerceStoresIdCartsIdLinesIdRequest) (*ECommerceCartLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCartLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdCartsIdLinesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	customerId string
	body *ECommerceCustomer4
}

func (r EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest) Body(body ECommerceCustomer4) EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest) Execute() (*ECommerceCustomer, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdCustomersIdExecute(r)
}

/*
PatchEcommerceStoresIdCustomersId Update customer

Update a customer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param customerId The id for the customer of a store.
 @return EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		customerId: customerId,
	}
}

// Execute executes the request
//  @return ECommerceCustomer
func (a *EcommerceAPIService) PatchEcommerceStoresIdCustomersIdExecute(r EcommerceAPIPatchEcommerceStoresIdCustomersIdRequest) (*ECommerceCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdCustomersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers/{customer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customer_id"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	orderId string
	body *ECommerceOrder2
}

func (r EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest) Body(body ECommerceOrder2) EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest) Execute() (*ECommerceOrder, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdOrdersIdExecute(r)
}

/*
PatchEcommerceStoresIdOrdersId Update order

Update a specific order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdOrdersId(ctx context.Context, storeId string, orderId string) EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return ECommerceOrder
func (a *EcommerceAPIService) PatchEcommerceStoresIdOrdersIdExecute(r EcommerceAPIPatchEcommerceStoresIdOrdersIdRequest) (*ECommerceOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdOrdersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	orderId string
	lineId string
	body *ECommerceOrderLineItem2
}

func (r EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest) Body(body ECommerceOrderLineItem2) EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest) Execute() (*ECommerceOrderLineItem, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdOrdersIdLinesIdExecute(r)
}

/*
PatchEcommerceStoresIdOrdersIdLinesId Update order line item

Update a specific order line item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @param lineId The id for the line item of an order.
 @return EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdOrdersIdLinesId(ctx context.Context, storeId string, orderId string, lineId string) EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
		lineId: lineId,
	}
}

// Execute executes the request
//  @return ECommerceOrderLineItem
func (a *EcommerceAPIService) PatchEcommerceStoresIdOrdersIdLinesIdExecute(r EcommerceAPIPatchEcommerceStoresIdOrdersIdLinesIdRequest) (*ECommerceOrderLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrderLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdOrdersIdLinesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines/{line_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"line_id"+"}", url.PathEscape(parameterValueToString(r.lineId, "lineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdProductsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	body *ECommerceProduct2
}

func (r EcommerceAPIPatchEcommerceStoresIdProductsIdRequest) Body(body ECommerceProduct2) EcommerceAPIPatchEcommerceStoresIdProductsIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdProductsIdRequest) Execute() (*ECommerceProduct, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdProductsIdExecute(r)
}

/*
PatchEcommerceStoresIdProductsId Update product

Update a specific product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return EcommerceAPIPatchEcommerceStoresIdProductsIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsId(ctx context.Context, storeId string, productId string) EcommerceAPIPatchEcommerceStoresIdProductsIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdProductsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ECommerceProduct
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdExecute(r EcommerceAPIPatchEcommerceStoresIdProductsIdRequest) (*ECommerceProduct, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProduct
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdProductsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	imageId string
	body *ECommerceProductImage2
}

func (r EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest) Body(body ECommerceProductImage2) EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest) Execute() (*ECommerceProductImage, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdProductsIdImagesIdExecute(r)
}

/*
PatchEcommerceStoresIdProductsIdImagesId Update product image

Update a product image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param imageId The id for the product image.
 @return EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdImagesId(ctx context.Context, storeId string, productId string, imageId string) EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		imageId: imageId,
	}
}

// Execute executes the request
//  @return ECommerceProductImage
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdImagesIdExecute(r EcommerceAPIPatchEcommerceStoresIdProductsIdImagesIdRequest) (*ECommerceProductImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdProductsIdImagesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images/{image_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"image_id"+"}", url.PathEscape(parameterValueToString(r.imageId, "imageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	variantId string
	body *ECommerceProductVariant2
}

func (r EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest) Body(body ECommerceProductVariant2) EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest) Execute() (*ECommerceProductVariant, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdProductsIdVariantsIdExecute(r)
}

/*
PatchEcommerceStoresIdProductsIdVariantsId Update product variant

Update a product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param variantId The id for the product variant.
 @return EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		variantId: variantId,
	}
}

// Execute executes the request
//  @return ECommerceProductVariant
func (a *EcommerceAPIService) PatchEcommerceStoresIdProductsIdVariantsIdExecute(r EcommerceAPIPatchEcommerceStoresIdProductsIdVariantsIdRequest) (*ECommerceProductVariant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductVariant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdProductsIdVariantsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants/{variant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variant_id"+"}", url.PathEscape(parameterValueToString(r.variantId, "variantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	promoRuleId string
	promoCodeId string
	body *ECommercePromoCode2
}

func (r EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest) Body(body ECommercePromoCode2) EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest) Execute() (*ECommercePromoCode, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdPromocodesIdExecute(r)
}

/*
PatchEcommerceStoresIdPromocodesId Update promo code

Update a promo code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @param promoCodeId The id for the promo code of a store.
 @return EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdPromocodesId(ctx context.Context, storeId string, promoRuleId string, promoCodeId string) EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
		promoCodeId: promoCodeId,
	}
}

// Execute executes the request
//  @return ECommercePromoCode
func (a *EcommerceAPIService) PatchEcommerceStoresIdPromocodesIdExecute(r EcommerceAPIPatchEcommerceStoresIdPromocodesIdRequest) (*ECommercePromoCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdPromocodesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes/{promo_code_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_code_id"+"}", url.PathEscape(parameterValueToString(r.promoCodeId, "promoCodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	promoRuleId string
	body *ECommercePromoRule2
}

func (r EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest) Body(body ECommercePromoRule2) EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest) Execute() (*ECommercePromoRule, *http.Response, error) {
	return r.ApiService.PatchEcommerceStoresIdPromorulesIdExecute(r)
}

/*
PatchEcommerceStoresIdPromorulesId Update promo rule

Update a promo rule.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @return EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest
*/
func (a *EcommerceAPIService) PatchEcommerceStoresIdPromorulesId(ctx context.Context, storeId string, promoRuleId string) EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest {
	return EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
	}
}

// Execute executes the request
//  @return ECommercePromoRule
func (a *EcommerceAPIService) PatchEcommerceStoresIdPromorulesIdExecute(r EcommerceAPIPatchEcommerceStoresIdPromorulesIdRequest) (*ECommercePromoRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PatchEcommerceStoresIdPromorulesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	body *ECommerceStore1
}

func (r EcommerceAPIPostEcommerceStoresRequest) Body(body ECommerceStore1) EcommerceAPIPostEcommerceStoresRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresRequest) Execute() (*ECommerceStore, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresExecute(r)
}

/*
PostEcommerceStores Add store

Add a new store to your Mailchimp account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return EcommerceAPIPostEcommerceStoresRequest
*/
func (a *EcommerceAPIService) PostEcommerceStores(ctx context.Context) EcommerceAPIPostEcommerceStoresRequest {
	return EcommerceAPIPostEcommerceStoresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ECommerceStore
func (a *EcommerceAPIService) PostEcommerceStoresExecute(r EcommerceAPIPostEcommerceStoresRequest) (*ECommerceStore, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceStore
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStores")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdCartsRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	body *ECommerceCart1
}

func (r EcommerceAPIPostEcommerceStoresIdCartsRequest) Body(body ECommerceCart1) EcommerceAPIPostEcommerceStoresIdCartsRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdCartsRequest) Execute() (*ECommerceCart, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdCartsExecute(r)
}

/*
PostEcommerceStoresIdCarts Add cart

Add a new cart to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIPostEcommerceStoresIdCartsRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdCarts(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdCartsRequest {
	return EcommerceAPIPostEcommerceStoresIdCartsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceCart
func (a *EcommerceAPIService) PostEcommerceStoresIdCartsExecute(r EcommerceAPIPostEcommerceStoresIdCartsRequest) (*ECommerceCart, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCart
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdCarts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	cartId string
	body *ECommerceCartLineItem1
}

func (r EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest) Body(body ECommerceCartLineItem1) EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest) Execute() (*ECommerceCartLineItem, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdCartsIdLinesExecute(r)
}

/*
PostEcommerceStoresIdCartsIdLines Add cart line item

Add a new line item to an existing cart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param cartId The id for the cart.
 @return EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdCartsIdLines(ctx context.Context, storeId string, cartId string) EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest {
	return EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		cartId: cartId,
	}
}

// Execute executes the request
//  @return ECommerceCartLineItem
func (a *EcommerceAPIService) PostEcommerceStoresIdCartsIdLinesExecute(r EcommerceAPIPostEcommerceStoresIdCartsIdLinesRequest) (*ECommerceCartLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCartLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdCartsIdLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/carts/{cart_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cart_id"+"}", url.PathEscape(parameterValueToString(r.cartId, "cartId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdCustomersRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	body *ECommerceCustomer3
}

func (r EcommerceAPIPostEcommerceStoresIdCustomersRequest) Body(body ECommerceCustomer3) EcommerceAPIPostEcommerceStoresIdCustomersRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdCustomersRequest) Execute() (*ECommerceCustomer, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdCustomersExecute(r)
}

/*
PostEcommerceStoresIdCustomers Add customer

Add a new customer to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIPostEcommerceStoresIdCustomersRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdCustomers(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdCustomersRequest {
	return EcommerceAPIPostEcommerceStoresIdCustomersRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceCustomer
func (a *EcommerceAPIService) PostEcommerceStoresIdCustomersExecute(r EcommerceAPIPostEcommerceStoresIdCustomersRequest) (*ECommerceCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdCustomers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdOrdersRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	body *ECommerceOrder1
}

func (r EcommerceAPIPostEcommerceStoresIdOrdersRequest) Body(body ECommerceOrder1) EcommerceAPIPostEcommerceStoresIdOrdersRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdOrdersRequest) Execute() (*ECommerceOrder, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdOrdersExecute(r)
}

/*
PostEcommerceStoresIdOrders Add order

Add a new order to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIPostEcommerceStoresIdOrdersRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdOrders(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdOrdersRequest {
	return EcommerceAPIPostEcommerceStoresIdOrdersRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceOrder
func (a *EcommerceAPIService) PostEcommerceStoresIdOrdersExecute(r EcommerceAPIPostEcommerceStoresIdOrdersRequest) (*ECommerceOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	orderId string
	body *ECommerceOrderLineItem1
}

func (r EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest) Body(body ECommerceOrderLineItem1) EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest) Execute() (*ECommerceOrderLineItem, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdOrdersIdLinesExecute(r)
}

/*
PostEcommerceStoresIdOrdersIdLines Add order line item

Add a new line item to an existing order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param orderId The id for the order in a store.
 @return EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdOrdersIdLines(ctx context.Context, storeId string, orderId string) EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest {
	return EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return ECommerceOrderLineItem
func (a *EcommerceAPIService) PostEcommerceStoresIdOrdersIdLinesExecute(r EcommerceAPIPostEcommerceStoresIdOrdersIdLinesRequest) (*ECommerceOrderLineItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceOrderLineItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdOrdersIdLines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/orders/{order_id}/lines"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"order_id"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdProductsRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	body *ECommerceProduct1
}

func (r EcommerceAPIPostEcommerceStoresIdProductsRequest) Body(body ECommerceProduct1) EcommerceAPIPostEcommerceStoresIdProductsRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdProductsRequest) Execute() (*ECommerceProduct, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdProductsExecute(r)
}

/*
PostEcommerceStoresIdProducts Add product

Add a new product to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIPostEcommerceStoresIdProductsRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdProducts(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdProductsRequest {
	return EcommerceAPIPostEcommerceStoresIdProductsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommerceProduct
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsExecute(r EcommerceAPIPostEcommerceStoresIdProductsRequest) (*ECommerceProduct, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProduct
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdProducts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	body *ECommerceProductImage1
}

func (r EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest) Body(body ECommerceProductImage1) EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest) Execute() (*ECommerceProductImage, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdProductsIdImagesExecute(r)
}

/*
PostEcommerceStoresIdProductsIdImages Add product image

Add a new image to the product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsIdImages(ctx context.Context, storeId string, productId string) EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest {
	return EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ECommerceProductImage
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsIdImagesExecute(r EcommerceAPIPostEcommerceStoresIdProductsIdImagesRequest) (*ECommerceProductImage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductImage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdProductsIdImages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	body *ECommerceProductVariant1
}

func (r EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest) Body(body ECommerceProductVariant1) EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest) Execute() (*ECommerceProductVariant, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdProductsIdVariantsExecute(r)
}

/*
PostEcommerceStoresIdProductsIdVariants Add product variant

Add a new variant to the product.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @return EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsIdVariants(ctx context.Context, storeId string, productId string) EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest {
	return EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ECommerceProductVariant
func (a *EcommerceAPIService) PostEcommerceStoresIdProductsIdVariantsExecute(r EcommerceAPIPostEcommerceStoresIdProductsIdVariantsRequest) (*ECommerceProductVariant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductVariant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdProductsIdVariants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdPromocodesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	promoRuleId string
	body *ECommercePromoCode1
}

func (r EcommerceAPIPostEcommerceStoresIdPromocodesRequest) Body(body ECommercePromoCode1) EcommerceAPIPostEcommerceStoresIdPromocodesRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdPromocodesRequest) Execute() (*ECommercePromoCode, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdPromocodesExecute(r)
}

/*
PostEcommerceStoresIdPromocodes Add promo code

Add a new promo code to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param promoRuleId The id for the promo rule of a store.
 @return EcommerceAPIPostEcommerceStoresIdPromocodesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdPromocodes(ctx context.Context, storeId string, promoRuleId string) EcommerceAPIPostEcommerceStoresIdPromocodesRequest {
	return EcommerceAPIPostEcommerceStoresIdPromocodesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		promoRuleId: promoRuleId,
	}
}

// Execute executes the request
//  @return ECommercePromoCode
func (a *EcommerceAPIService) PostEcommerceStoresIdPromocodesExecute(r EcommerceAPIPostEcommerceStoresIdPromocodesRequest) (*ECommercePromoCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdPromocodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules/{promo_rule_id}/promo-codes"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"promo_rule_id"+"}", url.PathEscape(parameterValueToString(r.promoRuleId, "promoRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPostEcommerceStoresIdPromorulesRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	body *ECommercePromoRule1
}

func (r EcommerceAPIPostEcommerceStoresIdPromorulesRequest) Body(body ECommercePromoRule1) EcommerceAPIPostEcommerceStoresIdPromorulesRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPostEcommerceStoresIdPromorulesRequest) Execute() (*ECommercePromoRule, *http.Response, error) {
	return r.ApiService.PostEcommerceStoresIdPromorulesExecute(r)
}

/*
PostEcommerceStoresIdPromorules Add promo rule

Add a new promo rule to a store.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @return EcommerceAPIPostEcommerceStoresIdPromorulesRequest
*/
func (a *EcommerceAPIService) PostEcommerceStoresIdPromorules(ctx context.Context, storeId string) EcommerceAPIPostEcommerceStoresIdPromorulesRequest {
	return EcommerceAPIPostEcommerceStoresIdPromorulesRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
	}
}

// Execute executes the request
//  @return ECommercePromoRule
func (a *EcommerceAPIService) PostEcommerceStoresIdPromorulesExecute(r EcommerceAPIPostEcommerceStoresIdPromorulesRequest) (*ECommercePromoRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommercePromoRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PostEcommerceStoresIdPromorules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/promo-rules"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPutEcommerceStoresIdCustomersIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	customerId string
	body *ECommerceCustomer2
}

func (r EcommerceAPIPutEcommerceStoresIdCustomersIdRequest) Body(body ECommerceCustomer2) EcommerceAPIPutEcommerceStoresIdCustomersIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPutEcommerceStoresIdCustomersIdRequest) Execute() (*ECommerceCustomer, *http.Response, error) {
	return r.ApiService.PutEcommerceStoresIdCustomersIdExecute(r)
}

/*
PutEcommerceStoresIdCustomersId Add or update customer

Add or update a customer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param customerId The id for the customer of a store.
 @return EcommerceAPIPutEcommerceStoresIdCustomersIdRequest
*/
func (a *EcommerceAPIService) PutEcommerceStoresIdCustomersId(ctx context.Context, storeId string, customerId string) EcommerceAPIPutEcommerceStoresIdCustomersIdRequest {
	return EcommerceAPIPutEcommerceStoresIdCustomersIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		customerId: customerId,
	}
}

// Execute executes the request
//  @return ECommerceCustomer
func (a *EcommerceAPIService) PutEcommerceStoresIdCustomersIdExecute(r EcommerceAPIPutEcommerceStoresIdCustomersIdRequest) (*ECommerceCustomer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceCustomer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PutEcommerceStoresIdCustomersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/customers/{customer_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"customer_id"+"}", url.PathEscape(parameterValueToString(r.customerId, "customerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest struct {
	ctx context.Context
	ApiService EcommerceAPI
	storeId string
	productId string
	variantId string
	body *ECommerceProductVariant1
}

func (r EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest) Body(body ECommerceProductVariant1) EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest {
	r.body = &body
	return r
}

func (r EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest) Execute() (*ECommerceProductVariant, *http.Response, error) {
	return r.ApiService.PutEcommerceStoresIdProductsIdVariantsIdExecute(r)
}

/*
PutEcommerceStoresIdProductsIdVariantsId Add or update product variant

Add or update a product variant.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param storeId The store id.
 @param productId The id for the product of a store.
 @param variantId The id for the product variant.
 @return EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest
*/
func (a *EcommerceAPIService) PutEcommerceStoresIdProductsIdVariantsId(ctx context.Context, storeId string, productId string, variantId string) EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest {
	return EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest{
		ApiService: a,
		ctx: ctx,
		storeId: storeId,
		productId: productId,
		variantId: variantId,
	}
}

// Execute executes the request
//  @return ECommerceProductVariant
func (a *EcommerceAPIService) PutEcommerceStoresIdProductsIdVariantsIdExecute(r EcommerceAPIPutEcommerceStoresIdProductsIdVariantsIdRequest) (*ECommerceProductVariant, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ECommerceProductVariant
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EcommerceAPIService.PutEcommerceStoresIdProductsIdVariantsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ecommerce/stores/{store_id}/products/{product_id}/variants/{variant_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"store_id"+"}", url.PathEscape(parameterValueToString(r.storeId, "storeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"product_id"+"}", url.PathEscape(parameterValueToString(r.productId, "productId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variant_id"+"}", url.PathEscape(parameterValueToString(r.variantId, "variantId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
