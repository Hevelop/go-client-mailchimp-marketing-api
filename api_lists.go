/*
Mailchimp Marketing API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 3.0.55
Contact: apihelp@mailchimp.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mailchimpmarketingapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ListsAPI interface {

	/*
	DeleteListsId Delete list

	Delete a list from your Mailchimp account. If you delete a list, you'll lose the list history—including subscriber activity, unsubscribes, complaints, and bounces. You’ll also lose subscribers’ email addresses, unless you exported and backed up your list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIDeleteListsIdRequest
	*/
	DeleteListsId(ctx context.Context, listId string) ListsAPIDeleteListsIdRequest

	// DeleteListsIdExecute executes the request
	DeleteListsIdExecute(r ListsAPIDeleteListsIdRequest) (*http.Response, error)

	/*
	DeleteListsIdInterestCategoriesId Delete interest category

	Delete a specific interest category.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param interestCategoryId The unique ID for the interest category.
	@return ListsAPIDeleteListsIdInterestCategoriesIdRequest
	*/
	DeleteListsIdInterestCategoriesId(ctx context.Context, listId string, interestCategoryId string) ListsAPIDeleteListsIdInterestCategoriesIdRequest

	// DeleteListsIdInterestCategoriesIdExecute executes the request
	DeleteListsIdInterestCategoriesIdExecute(r ListsAPIDeleteListsIdInterestCategoriesIdRequest) (*http.Response, error)

	/*
	DeleteListsIdInterestCategoriesIdInterestsId Delete interest in category

	Delete interests or group names in a specific category.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param interestCategoryId The unique ID for the interest category.
	@param interestId The specific interest or 'group name'.
	@return ListsAPIDeleteListsIdInterestCategoriesIdInterestsIdRequest
	*/
	DeleteListsIdInterestCategoriesIdInterestsId(ctx context.Context, listId string, interestCategoryId string, interestId string) ListsAPIDeleteListsIdInterestCategoriesIdInterestsIdRequest

	// DeleteListsIdInterestCategoriesIdInterestsIdExecute executes the request
	DeleteListsIdInterestCategoriesIdInterestsIdExecute(r ListsAPIDeleteListsIdInterestCategoriesIdInterestsIdRequest) (*http.Response, error)

	/*
	DeleteListsIdMembersId Archive list member

	Archive a list member. To permanently delete, use the delete-permanent action.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIDeleteListsIdMembersIdRequest
	*/
	DeleteListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ListsAPIDeleteListsIdMembersIdRequest

	// DeleteListsIdMembersIdExecute executes the request
	DeleteListsIdMembersIdExecute(r ListsAPIDeleteListsIdMembersIdRequest) (*http.Response, error)

	/*
	DeleteListsIdMembersIdNotesId Delete note

	Delete a specific note for a specific list member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@param noteId The id for the note.
	@return ListsAPIDeleteListsIdMembersIdNotesIdRequest
	*/
	DeleteListsIdMembersIdNotesId(ctx context.Context, listId string, subscriberHash string, noteId string) ListsAPIDeleteListsIdMembersIdNotesIdRequest

	// DeleteListsIdMembersIdNotesIdExecute executes the request
	DeleteListsIdMembersIdNotesIdExecute(r ListsAPIDeleteListsIdMembersIdNotesIdRequest) (*http.Response, error)

	/*
	DeleteListsIdMergeFieldsId Delete merge field

	Delete a specific merge field.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param mergeId The id for the merge field.
	@return ListsAPIDeleteListsIdMergeFieldsIdRequest
	*/
	DeleteListsIdMergeFieldsId(ctx context.Context, listId string, mergeId string) ListsAPIDeleteListsIdMergeFieldsIdRequest

	// DeleteListsIdMergeFieldsIdExecute executes the request
	DeleteListsIdMergeFieldsIdExecute(r ListsAPIDeleteListsIdMergeFieldsIdRequest) (*http.Response, error)

	/*
	DeleteListsIdSegmentsId Delete segment

	Delete a specific segment in a list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param segmentId The unique id for the segment.
	@return ListsAPIDeleteListsIdSegmentsIdRequest
	*/
	DeleteListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ListsAPIDeleteListsIdSegmentsIdRequest

	// DeleteListsIdSegmentsIdExecute executes the request
	DeleteListsIdSegmentsIdExecute(r ListsAPIDeleteListsIdSegmentsIdRequest) (*http.Response, error)

	/*
	DeleteListsIdSegmentsIdMembersId Remove list member from segment

	Remove a member from the specified static segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param segmentId The unique id for the segment.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
	@return ListsAPIDeleteListsIdSegmentsIdMembersIdRequest
	*/
	DeleteListsIdSegmentsIdMembersId(ctx context.Context, listId string, segmentId string, subscriberHash string) ListsAPIDeleteListsIdSegmentsIdMembersIdRequest

	// DeleteListsIdSegmentsIdMembersIdExecute executes the request
	DeleteListsIdSegmentsIdMembersIdExecute(r ListsAPIDeleteListsIdSegmentsIdMembersIdRequest) (*http.Response, error)

	/*
	DeleteListsIdWebhooksId Delete webhook

	Delete a specific webhook in a list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param webhookId The webhook's id.
	@return ListsAPIDeleteListsIdWebhooksIdRequest
	*/
	DeleteListsIdWebhooksId(ctx context.Context, listId string, webhookId string) ListsAPIDeleteListsIdWebhooksIdRequest

	// DeleteListsIdWebhooksIdExecute executes the request
	DeleteListsIdWebhooksIdExecute(r ListsAPIDeleteListsIdWebhooksIdRequest) (*http.Response, error)

	/*
	GetListMemberTags List member tags

	Get the tags on a list member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIGetListMemberTagsRequest
	*/
	GetListMemberTags(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListMemberTagsRequest

	// GetListMemberTagsExecute executes the request
	//  @return CollectionOfTags
	GetListMemberTagsExecute(r ListsAPIGetListMemberTagsRequest) (*CollectionOfTags, *http.Response, error)

	/*
	GetLists Get lists info

	Get information about all lists in the account.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ListsAPIGetListsRequest
	*/
	GetLists(ctx context.Context) ListsAPIGetListsRequest

	// GetListsExecute executes the request
	//  @return SubscriberLists
	GetListsExecute(r ListsAPIGetListsRequest) (*SubscriberLists, *http.Response, error)

	/*
	GetListsId Get list info

	Get information about a specific list in your Mailchimp account. Results include list members who have signed up but haven't confirmed their subscription yet and unsubscribed or cleaned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdRequest
	*/
	GetListsId(ctx context.Context, listId string) ListsAPIGetListsIdRequest

	// GetListsIdExecute executes the request
	//  @return SubscriberList
	GetListsIdExecute(r ListsAPIGetListsIdRequest) (*SubscriberList, *http.Response, error)

	/*
	GetListsIdAbuseReports List abuse reports

	Get all abuse reports for a specific list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdAbuseReportsRequest
	*/
	GetListsIdAbuseReports(ctx context.Context, listId string) ListsAPIGetListsIdAbuseReportsRequest

	// GetListsIdAbuseReportsExecute executes the request
	//  @return AbuseComplaints
	GetListsIdAbuseReportsExecute(r ListsAPIGetListsIdAbuseReportsRequest) (*AbuseComplaints, *http.Response, error)

	/*
	GetListsIdAbuseReportsId Get abuse report

	Get details about a specific abuse report.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param reportId The id for the abuse report.
	@return ListsAPIGetListsIdAbuseReportsIdRequest
	*/
	GetListsIdAbuseReportsId(ctx context.Context, listId string, reportId string) ListsAPIGetListsIdAbuseReportsIdRequest

	// GetListsIdAbuseReportsIdExecute executes the request
	//  @return AbuseComplaint
	GetListsIdAbuseReportsIdExecute(r ListsAPIGetListsIdAbuseReportsIdRequest) (*AbuseComplaint, *http.Response, error)

	/*
	GetListsIdActivity List recent activity

	Get up to the previous 180 days of daily detailed aggregated activity stats for a list, not including Automation activity.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdActivityRequest
	*/
	GetListsIdActivity(ctx context.Context, listId string) ListsAPIGetListsIdActivityRequest

	// GetListsIdActivityExecute executes the request
	//  @return ListActivity
	GetListsIdActivityExecute(r ListsAPIGetListsIdActivityRequest) (*ListActivity, *http.Response, error)

	/*
	GetListsIdClients List top email clients

	Get a list of the top email clients based on user-agent strings.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdClientsRequest
	*/
	GetListsIdClients(ctx context.Context, listId string) ListsAPIGetListsIdClientsRequest

	// GetListsIdClientsExecute executes the request
	//  @return EmailClients
	GetListsIdClientsExecute(r ListsAPIGetListsIdClientsRequest) (*EmailClients, *http.Response, error)

	/*
	GetListsIdGrowthHistory List growth history data

	Get a month-by-month summary of a specific list's growth activity.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdGrowthHistoryRequest
	*/
	GetListsIdGrowthHistory(ctx context.Context, listId string) ListsAPIGetListsIdGrowthHistoryRequest

	// GetListsIdGrowthHistoryExecute executes the request
	//  @return GrowthHistory
	GetListsIdGrowthHistoryExecute(r ListsAPIGetListsIdGrowthHistoryRequest) (*GrowthHistory, *http.Response, error)

	/*
	GetListsIdGrowthHistoryId Get growth history by month

	Get a summary of a specific list's growth activity for a specific month and year.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param month A specific month of list growth history.
	@return ListsAPIGetListsIdGrowthHistoryIdRequest
	*/
	GetListsIdGrowthHistoryId(ctx context.Context, listId string, month string) ListsAPIGetListsIdGrowthHistoryIdRequest

	// GetListsIdGrowthHistoryIdExecute executes the request
	//  @return GrowthHistory
	GetListsIdGrowthHistoryIdExecute(r ListsAPIGetListsIdGrowthHistoryIdRequest) (*GrowthHistory, *http.Response, error)

	/*
	GetListsIdInterestCategories List interest categories

	Get information about a list's interest categories.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdInterestCategoriesRequest
	*/
	GetListsIdInterestCategories(ctx context.Context, listId string) ListsAPIGetListsIdInterestCategoriesRequest

	// GetListsIdInterestCategoriesExecute executes the request
	//  @return InterestGroupings
	GetListsIdInterestCategoriesExecute(r ListsAPIGetListsIdInterestCategoriesRequest) (*InterestGroupings, *http.Response, error)

	/*
	GetListsIdInterestCategoriesId Get interest category info

	Get information about a specific interest category.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param interestCategoryId The unique ID for the interest category.
	@return ListsAPIGetListsIdInterestCategoriesIdRequest
	*/
	GetListsIdInterestCategoriesId(ctx context.Context, listId string, interestCategoryId string) ListsAPIGetListsIdInterestCategoriesIdRequest

	// GetListsIdInterestCategoriesIdExecute executes the request
	//  @return InterestCategory
	GetListsIdInterestCategoriesIdExecute(r ListsAPIGetListsIdInterestCategoriesIdRequest) (*InterestCategory, *http.Response, error)

	/*
	GetListsIdInterestCategoriesIdInterests List interests in category

	Get a list of this category's interests.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param interestCategoryId The unique ID for the interest category.
	@return ListsAPIGetListsIdInterestCategoriesIdInterestsRequest
	*/
	GetListsIdInterestCategoriesIdInterests(ctx context.Context, listId string, interestCategoryId string) ListsAPIGetListsIdInterestCategoriesIdInterestsRequest

	// GetListsIdInterestCategoriesIdInterestsExecute executes the request
	//  @return Interests
	GetListsIdInterestCategoriesIdInterestsExecute(r ListsAPIGetListsIdInterestCategoriesIdInterestsRequest) (*Interests, *http.Response, error)

	/*
	GetListsIdInterestCategoriesIdInterestsId Get interest in category

	Get interests or 'group names' for a specific category.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param interestCategoryId The unique ID for the interest category.
	@param interestId The specific interest or 'group name'.
	@return ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest
	*/
	GetListsIdInterestCategoriesIdInterestsId(ctx context.Context, listId string, interestCategoryId string, interestId string) ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest

	// GetListsIdInterestCategoriesIdInterestsIdExecute executes the request
	//  @return Interest
	GetListsIdInterestCategoriesIdInterestsIdExecute(r ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest) (*Interest, *http.Response, error)

	/*
	GetListsIdLocations List locations

	Get the locations (countries) that the list's subscribers have been tagged to based on geocoding their IP address.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdLocationsRequest
	*/
	GetListsIdLocations(ctx context.Context, listId string) ListsAPIGetListsIdLocationsRequest

	// GetListsIdLocationsExecute executes the request
	//  @return ListLocations
	GetListsIdLocationsExecute(r ListsAPIGetListsIdLocationsRequest) (*ListLocations, *http.Response, error)

	/*
	GetListsIdMembers List members info

	Get information about members in a specific Mailchimp list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdMembersRequest
	*/
	GetListsIdMembers(ctx context.Context, listId string) ListsAPIGetListsIdMembersRequest

	// GetListsIdMembersExecute executes the request
	//  @return ListMembers2
	GetListsIdMembersExecute(r ListsAPIGetListsIdMembersRequest) (*ListMembers2, *http.Response, error)

	/*
	GetListsIdMembersId Get member info

	Get information about a specific list member, including a currently subscribed, unsubscribed, or bounced member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIGetListsIdMembersIdRequest
	*/
	GetListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdRequest

	// GetListsIdMembersIdExecute executes the request
	//  @return ListMembers2
	GetListsIdMembersIdExecute(r ListsAPIGetListsIdMembersIdRequest) (*ListMembers2, *http.Response, error)

	/*
	GetListsIdMembersIdActivity View recent activity 50

	Get the last 50 events of a member's activity on a specific list, including opens, clicks, and unsubscribes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIGetListsIdMembersIdActivityRequest
	*/
	GetListsIdMembersIdActivity(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdActivityRequest

	// GetListsIdMembersIdActivityExecute executes the request
	//  @return MemberActivityEvents
	GetListsIdMembersIdActivityExecute(r ListsAPIGetListsIdMembersIdActivityRequest) (*MemberActivityEvents, *http.Response, error)

	/*
	GetListsIdMembersIdActivityFeed View recent activity

	Get a member's activity on a specific list, including opens, clicks, and unsubscribes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIGetListsIdMembersIdActivityFeedRequest
	*/
	GetListsIdMembersIdActivityFeed(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdActivityFeedRequest

	// GetListsIdMembersIdActivityFeedExecute executes the request
	//  @return MemberActivityEvents1
	GetListsIdMembersIdActivityFeedExecute(r ListsAPIGetListsIdMembersIdActivityFeedRequest) (*MemberActivityEvents1, *http.Response, error)

	/*
	GetListsIdMembersIdEvents List member events

	Get events for a contact.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIGetListsIdMembersIdEventsRequest
	*/
	GetListsIdMembersIdEvents(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdEventsRequest

	// GetListsIdMembersIdEventsExecute executes the request
	//  @return CollectionOfEvents
	GetListsIdMembersIdEventsExecute(r ListsAPIGetListsIdMembersIdEventsRequest) (*CollectionOfEvents, *http.Response, error)

	/*
	GetListsIdMembersIdGoals List member goal events

	Get the last 50 Goal events for a member on a specific list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIGetListsIdMembersIdGoalsRequest
	*/
	GetListsIdMembersIdGoals(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdGoalsRequest

	// GetListsIdMembersIdGoalsExecute executes the request
	//  @return CollectionOfMemberActivityEvents
	GetListsIdMembersIdGoalsExecute(r ListsAPIGetListsIdMembersIdGoalsRequest) (*CollectionOfMemberActivityEvents, *http.Response, error)

	/*
	GetListsIdMembersIdNotes List recent member notes

	Get recent notes for a specific list member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
	@return ListsAPIGetListsIdMembersIdNotesRequest
	*/
	GetListsIdMembersIdNotes(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdNotesRequest

	// GetListsIdMembersIdNotesExecute executes the request
	//  @return CollectionOfNotes
	GetListsIdMembersIdNotesExecute(r ListsAPIGetListsIdMembersIdNotesRequest) (*CollectionOfNotes, *http.Response, error)

	/*
	GetListsIdMembersIdNotesId Get member note

	Get a specific note for a specific list member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@param noteId The id for the note.
	@return ListsAPIGetListsIdMembersIdNotesIdRequest
	*/
	GetListsIdMembersIdNotesId(ctx context.Context, listId string, subscriberHash string, noteId string) ListsAPIGetListsIdMembersIdNotesIdRequest

	// GetListsIdMembersIdNotesIdExecute executes the request
	//  @return MemberNotes
	GetListsIdMembersIdNotesIdExecute(r ListsAPIGetListsIdMembersIdNotesIdRequest) (*MemberNotes, *http.Response, error)

	/*
	GetListsIdMergeFields List merge fields

	Get a list of all merge fields for an audience.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdMergeFieldsRequest
	*/
	GetListsIdMergeFields(ctx context.Context, listId string) ListsAPIGetListsIdMergeFieldsRequest

	// GetListsIdMergeFieldsExecute executes the request
	//  @return CollectionOfMergeFields
	GetListsIdMergeFieldsExecute(r ListsAPIGetListsIdMergeFieldsRequest) (*CollectionOfMergeFields, *http.Response, error)

	/*
	GetListsIdMergeFieldsId Get merge field

	Get information about a specific merge field.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param mergeId The id for the merge field.
	@return ListsAPIGetListsIdMergeFieldsIdRequest
	*/
	GetListsIdMergeFieldsId(ctx context.Context, listId string, mergeId string) ListsAPIGetListsIdMergeFieldsIdRequest

	// GetListsIdMergeFieldsIdExecute executes the request
	//  @return MergeField
	GetListsIdMergeFieldsIdExecute(r ListsAPIGetListsIdMergeFieldsIdRequest) (*MergeField, *http.Response, error)

	/*
	GetListsIdSegmentsId Get segment info

	Get information about a specific segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param segmentId The unique id for the segment.
	@return ListsAPIGetListsIdSegmentsIdRequest
	*/
	GetListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ListsAPIGetListsIdSegmentsIdRequest

	// GetListsIdSegmentsIdExecute executes the request
	//  @return List7
	GetListsIdSegmentsIdExecute(r ListsAPIGetListsIdSegmentsIdRequest) (*List7, *http.Response, error)

	/*
	GetListsIdSegmentsIdMembers List members in segment

	Get information about members in a saved segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param segmentId The unique id for the segment.
	@return ListsAPIGetListsIdSegmentsIdMembersRequest
	*/
	GetListsIdSegmentsIdMembers(ctx context.Context, listId string, segmentId string) ListsAPIGetListsIdSegmentsIdMembersRequest

	// GetListsIdSegmentsIdMembersExecute executes the request
	//  @return SegmentMembers
	GetListsIdSegmentsIdMembersExecute(r ListsAPIGetListsIdSegmentsIdMembersRequest) (*SegmentMembers, *http.Response, error)

	/*
	GetListsIdSignupForms List signup forms

	Get signup forms for a specific list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdSignupFormsRequest
	*/
	GetListsIdSignupForms(ctx context.Context, listId string) ListsAPIGetListsIdSignupFormsRequest

	// GetListsIdSignupFormsExecute executes the request
	//  @return ListSignupForms
	GetListsIdSignupFormsExecute(r ListsAPIGetListsIdSignupFormsRequest) (*ListSignupForms, *http.Response, error)

	/*
	GetListsIdSurveys Get information about all surveys for a list

	Get information about all available surveys for a specific list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdSurveysRequest
	*/
	GetListsIdSurveys(ctx context.Context, listId string) ListsAPIGetListsIdSurveysRequest

	// GetListsIdSurveysExecute executes the request
	GetListsIdSurveysExecute(r ListsAPIGetListsIdSurveysRequest) (*http.Response, error)

	/*
	GetListsIdSurveysId Get survey

	Get details about a specific survey.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param surveyId The ID of the survey.
	@return ListsAPIGetListsIdSurveysIdRequest
	*/
	GetListsIdSurveysId(ctx context.Context, listId string, surveyId string) ListsAPIGetListsIdSurveysIdRequest

	// GetListsIdSurveysIdExecute executes the request
	GetListsIdSurveysIdExecute(r ListsAPIGetListsIdSurveysIdRequest) (*http.Response, error)

	/*
	GetListsIdWebhooks List webhooks

	Get information about all webhooks for a specific list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIGetListsIdWebhooksRequest
	*/
	GetListsIdWebhooks(ctx context.Context, listId string) ListsAPIGetListsIdWebhooksRequest

	// GetListsIdWebhooksExecute executes the request
	//  @return ListWebhooks
	GetListsIdWebhooksExecute(r ListsAPIGetListsIdWebhooksRequest) (*ListWebhooks, *http.Response, error)

	/*
	GetListsIdWebhooksId Get webhook info

	Get information about a specific webhook.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param webhookId The webhook's id.
	@return ListsAPIGetListsIdWebhooksIdRequest
	*/
	GetListsIdWebhooksId(ctx context.Context, listId string, webhookId string) ListsAPIGetListsIdWebhooksIdRequest

	// GetListsIdWebhooksIdExecute executes the request
	//  @return ListWebhooks
	GetListsIdWebhooksIdExecute(r ListsAPIGetListsIdWebhooksIdRequest) (*ListWebhooks, *http.Response, error)

	/*
	PatchListsId Update lists

	Update the settings for a specific list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIPatchListsIdRequest
	*/
	PatchListsId(ctx context.Context, listId string) ListsAPIPatchListsIdRequest

	// PatchListsIdExecute executes the request
	//  @return SubscriberList
	PatchListsIdExecute(r ListsAPIPatchListsIdRequest) (*SubscriberList, *http.Response, error)

	/*
	PatchListsIdInterestCategoriesId Update interest category

	Update a specific interest category.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param interestCategoryId The unique ID for the interest category.
	@return ListsAPIPatchListsIdInterestCategoriesIdRequest
	*/
	PatchListsIdInterestCategoriesId(ctx context.Context, listId string, interestCategoryId string) ListsAPIPatchListsIdInterestCategoriesIdRequest

	// PatchListsIdInterestCategoriesIdExecute executes the request
	//  @return InterestCategory
	PatchListsIdInterestCategoriesIdExecute(r ListsAPIPatchListsIdInterestCategoriesIdRequest) (*InterestCategory, *http.Response, error)

	/*
	PatchListsIdInterestCategoriesIdInterestsId Update interest in category

	Update interests or 'group names' for a specific category.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param interestCategoryId The unique ID for the interest category.
	@param interestId The specific interest or 'group name'.
	@return ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest
	*/
	PatchListsIdInterestCategoriesIdInterestsId(ctx context.Context, listId string, interestCategoryId string, interestId string) ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest

	// PatchListsIdInterestCategoriesIdInterestsIdExecute executes the request
	//  @return Interest
	PatchListsIdInterestCategoriesIdInterestsIdExecute(r ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest) (*Interest, *http.Response, error)

	/*
	PatchListsIdMembersId Update list member

	Update information for a specific list member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIPatchListsIdMembersIdRequest
	*/
	PatchListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ListsAPIPatchListsIdMembersIdRequest

	// PatchListsIdMembersIdExecute executes the request
	//  @return ListMembers2
	PatchListsIdMembersIdExecute(r ListsAPIPatchListsIdMembersIdRequest) (*ListMembers2, *http.Response, error)

	/*
	PatchListsIdMembersIdNotesId Update note

	Update a specific note for a specific list member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@param noteId The id for the note.
	@return ListsAPIPatchListsIdMembersIdNotesIdRequest
	*/
	PatchListsIdMembersIdNotesId(ctx context.Context, listId string, subscriberHash string, noteId string) ListsAPIPatchListsIdMembersIdNotesIdRequest

	// PatchListsIdMembersIdNotesIdExecute executes the request
	//  @return MemberNotes
	PatchListsIdMembersIdNotesIdExecute(r ListsAPIPatchListsIdMembersIdNotesIdRequest) (*MemberNotes, *http.Response, error)

	/*
	PatchListsIdMergeFieldsId Update merge field

	Update a specific merge field.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param mergeId The id for the merge field.
	@return ListsAPIPatchListsIdMergeFieldsIdRequest
	*/
	PatchListsIdMergeFieldsId(ctx context.Context, listId string, mergeId string) ListsAPIPatchListsIdMergeFieldsIdRequest

	// PatchListsIdMergeFieldsIdExecute executes the request
	//  @return MergeField
	PatchListsIdMergeFieldsIdExecute(r ListsAPIPatchListsIdMergeFieldsIdRequest) (*MergeField, *http.Response, error)

	/*
	PatchListsIdSegmentsId Update segment

	Update a specific segment in a list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param segmentId The unique id for the segment.
	@return ListsAPIPatchListsIdSegmentsIdRequest
	*/
	PatchListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ListsAPIPatchListsIdSegmentsIdRequest

	// PatchListsIdSegmentsIdExecute executes the request
	//  @return List7
	PatchListsIdSegmentsIdExecute(r ListsAPIPatchListsIdSegmentsIdRequest) (*List7, *http.Response, error)

	/*
	PatchListsIdWebhooksId Update webhook

	Update the settings for an existing webhook.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param webhookId The webhook's id.
	@return ListsAPIPatchListsIdWebhooksIdRequest
	*/
	PatchListsIdWebhooksId(ctx context.Context, listId string, webhookId string) ListsAPIPatchListsIdWebhooksIdRequest

	// PatchListsIdWebhooksIdExecute executes the request
	//  @return ListWebhooks
	PatchListsIdWebhooksIdExecute(r ListsAPIPatchListsIdWebhooksIdRequest) (*ListWebhooks, *http.Response, error)

	/*
	PostListMemberEvents Add event

	Add an event for a list member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIPostListMemberEventsRequest
	*/
	PostListMemberEvents(ctx context.Context, listId string, subscriberHash string) ListsAPIPostListMemberEventsRequest

	// PostListMemberEventsExecute executes the request
	PostListMemberEventsExecute(r ListsAPIPostListMemberEventsRequest) (*http.Response, error)

	/*
	PostListMemberTags Add or remove member tags

	Add or remove tags from a list member. If a tag that does not exist is passed in and set as 'active', a new tag will be created.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
	@return ListsAPIPostListMemberTagsRequest
	*/
	PostListMemberTags(ctx context.Context, listId string, subscriberHash string) ListsAPIPostListMemberTagsRequest

	// PostListMemberTagsExecute executes the request
	PostListMemberTagsExecute(r ListsAPIPostListMemberTagsRequest) (*http.Response, error)

	/*
	PostLists Add list

	Create a new list in your Mailchimp account.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ListsAPIPostListsRequest
	*/
	PostLists(ctx context.Context) ListsAPIPostListsRequest

	// PostListsExecute executes the request
	//  @return SubscriberList
	PostListsExecute(r ListsAPIPostListsRequest) (*SubscriberList, *http.Response, error)

	/*
	PostListsId Batch subscribe or unsubscribe

	Batch subscribe or unsubscribe list members.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIPostListsIdRequest
	*/
	PostListsId(ctx context.Context, listId string) ListsAPIPostListsIdRequest

	// PostListsIdExecute executes the request
	//  @return BatchUpdateListMembers
	PostListsIdExecute(r ListsAPIPostListsIdRequest) (*BatchUpdateListMembers, *http.Response, error)

	/*
	PostListsIdInterestCategories Add interest category

	Create a new interest category.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIPostListsIdInterestCategoriesRequest
	*/
	PostListsIdInterestCategories(ctx context.Context, listId string) ListsAPIPostListsIdInterestCategoriesRequest

	// PostListsIdInterestCategoriesExecute executes the request
	//  @return InterestCategory
	PostListsIdInterestCategoriesExecute(r ListsAPIPostListsIdInterestCategoriesRequest) (*InterestCategory, *http.Response, error)

	/*
	PostListsIdInterestCategoriesIdInterests Add interest in category

	Create a new interest or 'group name' for a specific category.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param interestCategoryId The unique ID for the interest category.
	@return ListsAPIPostListsIdInterestCategoriesIdInterestsRequest
	*/
	PostListsIdInterestCategoriesIdInterests(ctx context.Context, listId string, interestCategoryId string) ListsAPIPostListsIdInterestCategoriesIdInterestsRequest

	// PostListsIdInterestCategoriesIdInterestsExecute executes the request
	//  @return Interest
	PostListsIdInterestCategoriesIdInterestsExecute(r ListsAPIPostListsIdInterestCategoriesIdInterestsRequest) (*Interest, *http.Response, error)

	/*
	PostListsIdMembers Add member to list

	Add a new member to the list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIPostListsIdMembersRequest
	*/
	PostListsIdMembers(ctx context.Context, listId string) ListsAPIPostListsIdMembersRequest

	// PostListsIdMembersExecute executes the request
	//  @return ListMembers2
	PostListsIdMembersExecute(r ListsAPIPostListsIdMembersRequest) (*ListMembers2, *http.Response, error)

	/*
	PostListsIdMembersHashActionsDeletePermanent Delete list member

	Delete all personally identifiable information related to a list member, and remove them from a list. This will make it impossible to re-import the list member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
	@return ListsAPIPostListsIdMembersHashActionsDeletePermanentRequest
	*/
	PostListsIdMembersHashActionsDeletePermanent(ctx context.Context, listId string, subscriberHash string) ListsAPIPostListsIdMembersHashActionsDeletePermanentRequest

	// PostListsIdMembersHashActionsDeletePermanentExecute executes the request
	PostListsIdMembersHashActionsDeletePermanentExecute(r ListsAPIPostListsIdMembersHashActionsDeletePermanentRequest) (*http.Response, error)

	/*
	PostListsIdMembersIdNotes Add member note

	Add a new note for a specific subscriber.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
	@return ListsAPIPostListsIdMembersIdNotesRequest
	*/
	PostListsIdMembersIdNotes(ctx context.Context, listId string, subscriberHash string) ListsAPIPostListsIdMembersIdNotesRequest

	// PostListsIdMembersIdNotesExecute executes the request
	//  @return MemberNotes
	PostListsIdMembersIdNotesExecute(r ListsAPIPostListsIdMembersIdNotesRequest) (*MemberNotes, *http.Response, error)

	/*
	PostListsIdMergeFields Add merge field

	Add a new merge field for a specific audience.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIPostListsIdMergeFieldsRequest
	*/
	PostListsIdMergeFields(ctx context.Context, listId string) ListsAPIPostListsIdMergeFieldsRequest

	// PostListsIdMergeFieldsExecute executes the request
	//  @return MergeField
	PostListsIdMergeFieldsExecute(r ListsAPIPostListsIdMergeFieldsRequest) (*MergeField, *http.Response, error)

	/*
	PostListsIdSegments Add segment

	Create a new segment in a specific list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIPostListsIdSegmentsRequest
	*/
	PostListsIdSegments(ctx context.Context, listId string) ListsAPIPostListsIdSegmentsRequest

	// PostListsIdSegmentsExecute executes the request
	//  @return List7
	PostListsIdSegmentsExecute(r ListsAPIPostListsIdSegmentsRequest) (*List7, *http.Response, error)

	/*
	PostListsIdSegmentsId Batch add or remove members

	Batch add/remove list members to static segment

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param segmentId The unique id for the segment.
	@return ListsAPIPostListsIdSegmentsIdRequest
	*/
	PostListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ListsAPIPostListsIdSegmentsIdRequest

	// PostListsIdSegmentsIdExecute executes the request
	//  @return BatchAddRemoveListMembersToFromStaticSegment
	PostListsIdSegmentsIdExecute(r ListsAPIPostListsIdSegmentsIdRequest) (*BatchAddRemoveListMembersToFromStaticSegment, *http.Response, error)

	/*
	PostListsIdSegmentsIdMembers Add member to segment

	Add a member to a static segment.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param segmentId The unique id for the segment.
	@return ListsAPIPostListsIdSegmentsIdMembersRequest
	*/
	PostListsIdSegmentsIdMembers(ctx context.Context, listId string, segmentId string) ListsAPIPostListsIdSegmentsIdMembersRequest

	// PostListsIdSegmentsIdMembersExecute executes the request
	//  @return ListMembers1
	PostListsIdSegmentsIdMembersExecute(r ListsAPIPostListsIdSegmentsIdMembersRequest) (*ListMembers1, *http.Response, error)

	/*
	PostListsIdSignupForms Customize signup form

	Customize a list's default signup form.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIPostListsIdSignupFormsRequest
	*/
	PostListsIdSignupForms(ctx context.Context, listId string) ListsAPIPostListsIdSignupFormsRequest

	// PostListsIdSignupFormsExecute executes the request
	//  @return SignupForm
	PostListsIdSignupFormsExecute(r ListsAPIPostListsIdSignupFormsRequest) (*SignupForm, *http.Response, error)

	/*
	PostListsIdWebhooks Add webhook

	Create a new webhook for a specific list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIPostListsIdWebhooksRequest
	*/
	PostListsIdWebhooks(ctx context.Context, listId string) ListsAPIPostListsIdWebhooksRequest

	// PostListsIdWebhooksExecute executes the request
	//  @return ListWebhooks
	PostListsIdWebhooksExecute(r ListsAPIPostListsIdWebhooksRequest) (*ListWebhooks, *http.Response, error)

	/*
	PreviewASegment List segments

	Get information about all available segments for a specific list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPIPreviewASegmentRequest
	*/
	PreviewASegment(ctx context.Context, listId string) ListsAPIPreviewASegmentRequest

	// PreviewASegmentExecute executes the request
	//  @return CollectionOfSegments
	PreviewASegmentExecute(r ListsAPIPreviewASegmentRequest) (*CollectionOfSegments, *http.Response, error)

	/*
	PutListsIdMembersId Add or update list member

	Add or update a list member.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
	@return ListsAPIPutListsIdMembersIdRequest
	*/
	PutListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ListsAPIPutListsIdMembersIdRequest

	// PutListsIdMembersIdExecute executes the request
	//  @return ListMembers2
	PutListsIdMembersIdExecute(r ListsAPIPutListsIdMembersIdRequest) (*ListMembers2, *http.Response, error)

	/*
	SearchTagsByName Search for tags on a list by name.

	Search for tags on a list by name. If no name is provided, will return all tags on the list.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listId The unique ID for the list.
	@return ListsAPISearchTagsByNameRequest
	*/
	SearchTagsByName(ctx context.Context, listId string) ListsAPISearchTagsByNameRequest

	// SearchTagsByNameExecute executes the request
	//  @return TagSearchResults
	SearchTagsByNameExecute(r ListsAPISearchTagsByNameRequest) (*TagSearchResults, *http.Response, error)
}

// ListsAPIService ListsAPI service
type ListsAPIService service

type ListsAPIDeleteListsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
}

func (r ListsAPIDeleteListsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdExecute(r)
}

/*
DeleteListsId Delete list

Delete a list from your Mailchimp account. If you delete a list, you'll lose the list history—including subscriber activity, unsubscribes, complaints, and bounces. You’ll also lose subscribers’ email addresses, unless you exported and backed up your list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIDeleteListsIdRequest
*/
func (a *ListsAPIService) DeleteListsId(ctx context.Context, listId string) ListsAPIDeleteListsIdRequest {
	return ListsAPIDeleteListsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdExecute(r ListsAPIDeleteListsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIDeleteListsIdInterestCategoriesIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	interestCategoryId string
}

func (r ListsAPIDeleteListsIdInterestCategoriesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdInterestCategoriesIdExecute(r)
}

/*
DeleteListsIdInterestCategoriesId Delete interest category

Delete a specific interest category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ListsAPIDeleteListsIdInterestCategoriesIdRequest
*/
func (a *ListsAPIService) DeleteListsIdInterestCategoriesId(ctx context.Context, listId string, interestCategoryId string) ListsAPIDeleteListsIdInterestCategoriesIdRequest {
	return ListsAPIDeleteListsIdInterestCategoriesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdInterestCategoriesIdExecute(r ListsAPIDeleteListsIdInterestCategoriesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdInterestCategoriesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIDeleteListsIdInterestCategoriesIdInterestsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	interestCategoryId string
	interestId string
}

func (r ListsAPIDeleteListsIdInterestCategoriesIdInterestsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdInterestCategoriesIdInterestsIdExecute(r)
}

/*
DeleteListsIdInterestCategoriesIdInterestsId Delete interest in category

Delete interests or group names in a specific category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @param interestId The specific interest or 'group name'.
 @return ListsAPIDeleteListsIdInterestCategoriesIdInterestsIdRequest
*/
func (a *ListsAPIService) DeleteListsIdInterestCategoriesIdInterestsId(ctx context.Context, listId string, interestCategoryId string, interestId string) ListsAPIDeleteListsIdInterestCategoriesIdInterestsIdRequest {
	return ListsAPIDeleteListsIdInterestCategoriesIdInterestsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
		interestId: interestId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdInterestCategoriesIdInterestsIdExecute(r ListsAPIDeleteListsIdInterestCategoriesIdInterestsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdInterestCategoriesIdInterestsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_id"+"}", url.PathEscape(parameterValueToString(r.interestId, "interestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIDeleteListsIdMembersIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
}

func (r ListsAPIDeleteListsIdMembersIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdMembersIdExecute(r)
}

/*
DeleteListsIdMembersId Archive list member

Archive a list member. To permanently delete, use the delete-permanent action.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIDeleteListsIdMembersIdRequest
*/
func (a *ListsAPIService) DeleteListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ListsAPIDeleteListsIdMembersIdRequest {
	return ListsAPIDeleteListsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdMembersIdExecute(r ListsAPIDeleteListsIdMembersIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdMembersId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIDeleteListsIdMembersIdNotesIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	noteId string
}

func (r ListsAPIDeleteListsIdMembersIdNotesIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdMembersIdNotesIdExecute(r)
}

/*
DeleteListsIdMembersIdNotesId Delete note

Delete a specific note for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @param noteId The id for the note.
 @return ListsAPIDeleteListsIdMembersIdNotesIdRequest
*/
func (a *ListsAPIService) DeleteListsIdMembersIdNotesId(ctx context.Context, listId string, subscriberHash string, noteId string) ListsAPIDeleteListsIdMembersIdNotesIdRequest {
	return ListsAPIDeleteListsIdMembersIdNotesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
		noteId: noteId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdMembersIdNotesIdExecute(r ListsAPIDeleteListsIdMembersIdNotesIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdMembersIdNotesId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"note_id"+"}", url.PathEscape(parameterValueToString(r.noteId, "noteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIDeleteListsIdMergeFieldsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	mergeId string
}

func (r ListsAPIDeleteListsIdMergeFieldsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdMergeFieldsIdExecute(r)
}

/*
DeleteListsIdMergeFieldsId Delete merge field

Delete a specific merge field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param mergeId The id for the merge field.
 @return ListsAPIDeleteListsIdMergeFieldsIdRequest
*/
func (a *ListsAPIService) DeleteListsIdMergeFieldsId(ctx context.Context, listId string, mergeId string) ListsAPIDeleteListsIdMergeFieldsIdRequest {
	return ListsAPIDeleteListsIdMergeFieldsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		mergeId: mergeId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdMergeFieldsIdExecute(r ListsAPIDeleteListsIdMergeFieldsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdMergeFieldsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields/{merge_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_id"+"}", url.PathEscape(parameterValueToString(r.mergeId, "mergeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIDeleteListsIdSegmentsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	segmentId string
}

func (r ListsAPIDeleteListsIdSegmentsIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdSegmentsIdExecute(r)
}

/*
DeleteListsIdSegmentsId Delete segment

Delete a specific segment in a list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ListsAPIDeleteListsIdSegmentsIdRequest
*/
func (a *ListsAPIService) DeleteListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ListsAPIDeleteListsIdSegmentsIdRequest {
	return ListsAPIDeleteListsIdSegmentsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdSegmentsIdExecute(r ListsAPIDeleteListsIdSegmentsIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdSegmentsId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIDeleteListsIdSegmentsIdMembersIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	segmentId string
	subscriberHash string
}

func (r ListsAPIDeleteListsIdSegmentsIdMembersIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdSegmentsIdMembersIdExecute(r)
}

/*
DeleteListsIdSegmentsIdMembersId Remove list member from segment

Remove a member from the specified static segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ListsAPIDeleteListsIdSegmentsIdMembersIdRequest
*/
func (a *ListsAPIService) DeleteListsIdSegmentsIdMembersId(ctx context.Context, listId string, segmentId string, subscriberHash string) ListsAPIDeleteListsIdSegmentsIdMembersIdRequest {
	return ListsAPIDeleteListsIdSegmentsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdSegmentsIdMembersIdExecute(r ListsAPIDeleteListsIdSegmentsIdMembersIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdSegmentsIdMembersId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIDeleteListsIdWebhooksIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	webhookId string
}

func (r ListsAPIDeleteListsIdWebhooksIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListsIdWebhooksIdExecute(r)
}

/*
DeleteListsIdWebhooksId Delete webhook

Delete a specific webhook in a list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param webhookId The webhook's id.
 @return ListsAPIDeleteListsIdWebhooksIdRequest
*/
func (a *ListsAPIService) DeleteListsIdWebhooksId(ctx context.Context, listId string, webhookId string) ListsAPIDeleteListsIdWebhooksIdRequest {
	return ListsAPIDeleteListsIdWebhooksIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		webhookId: webhookId,
	}
}

// Execute executes the request
func (a *ListsAPIService) DeleteListsIdWebhooksIdExecute(r ListsAPIDeleteListsIdWebhooksIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.DeleteListsIdWebhooksId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks/{webhook_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhook_id"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIGetListMemberTagsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListMemberTagsRequest) Fields(fields []string) ListsAPIGetListMemberTagsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListMemberTagsRequest) ExcludeFields(excludeFields []string) ListsAPIGetListMemberTagsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListMemberTagsRequest) Count(count int32) ListsAPIGetListMemberTagsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListMemberTagsRequest) Offset(offset int32) ListsAPIGetListMemberTagsRequest {
	r.offset = &offset
	return r
}

func (r ListsAPIGetListMemberTagsRequest) Execute() (*CollectionOfTags, *http.Response, error) {
	return r.ApiService.GetListMemberTagsExecute(r)
}

/*
GetListMemberTags List member tags

Get the tags on a list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIGetListMemberTagsRequest
*/
func (a *ListsAPIService) GetListMemberTags(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListMemberTagsRequest {
	return ListsAPIGetListMemberTagsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return CollectionOfTags
func (a *ListsAPIService) GetListMemberTagsExecute(r ListsAPIGetListMemberTagsRequest) (*CollectionOfTags, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfTags
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListMemberTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	beforeDateCreated *string
	sinceDateCreated *string
	beforeCampaignLastSent *string
	sinceCampaignLastSent *string
	email *string
	sortField *string
	sortDir *string
	hasEcommerceStore *bool
	includeTotalContacts *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsRequest) Fields(fields []string) ListsAPIGetListsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsRequest) Count(count int32) ListsAPIGetListsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsRequest) Offset(offset int32) ListsAPIGetListsRequest {
	r.offset = &offset
	return r
}

// Restrict response to lists created before the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIGetListsRequest) BeforeDateCreated(beforeDateCreated string) ListsAPIGetListsRequest {
	r.beforeDateCreated = &beforeDateCreated
	return r
}

// Restrict results to lists created after the set date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIGetListsRequest) SinceDateCreated(sinceDateCreated string) ListsAPIGetListsRequest {
	r.sinceDateCreated = &sinceDateCreated
	return r
}

// Restrict results to lists created before the last campaign send date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIGetListsRequest) BeforeCampaignLastSent(beforeCampaignLastSent string) ListsAPIGetListsRequest {
	r.beforeCampaignLastSent = &beforeCampaignLastSent
	return r
}

// Restrict results to lists created after the last campaign send date. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIGetListsRequest) SinceCampaignLastSent(sinceCampaignLastSent string) ListsAPIGetListsRequest {
	r.sinceCampaignLastSent = &sinceCampaignLastSent
	return r
}

// Restrict results to lists that include a specific subscriber&#39;s email address.
func (r ListsAPIGetListsRequest) Email(email string) ListsAPIGetListsRequest {
	r.email = &email
	return r
}

// Returns files sorted by the specified field.
func (r ListsAPIGetListsRequest) SortField(sortField string) ListsAPIGetListsRequest {
	r.sortField = &sortField
	return r
}

// Determines the order direction for sorted results.
func (r ListsAPIGetListsRequest) SortDir(sortDir string) ListsAPIGetListsRequest {
	r.sortDir = &sortDir
	return r
}

// Restrict results to lists that contain an active, connected, undeleted ecommerce store.
func (r ListsAPIGetListsRequest) HasEcommerceStore(hasEcommerceStore bool) ListsAPIGetListsRequest {
	r.hasEcommerceStore = &hasEcommerceStore
	return r
}

// Return the total_contacts field in the stats response, which contains an approximate count of all contacts in any state.
func (r ListsAPIGetListsRequest) IncludeTotalContacts(includeTotalContacts bool) ListsAPIGetListsRequest {
	r.includeTotalContacts = &includeTotalContacts
	return r
}

func (r ListsAPIGetListsRequest) Execute() (*SubscriberLists, *http.Response, error) {
	return r.ApiService.GetListsExecute(r)
}

/*
GetLists Get lists info

Get information about all lists in the account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ListsAPIGetListsRequest
*/
func (a *ListsAPIService) GetLists(ctx context.Context) ListsAPIGetListsRequest {
	return ListsAPIGetListsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscriberLists
func (a *ListsAPIService) GetListsExecute(r ListsAPIGetListsRequest) (*SubscriberLists, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberLists
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetLists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.beforeDateCreated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_date_created", r.beforeDateCreated, "")
	}
	if r.sinceDateCreated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_date_created", r.sinceDateCreated, "")
	}
	if r.beforeCampaignLastSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_campaign_last_sent", r.beforeCampaignLastSent, "")
	}
	if r.sinceCampaignLastSent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_campaign_last_sent", r.sinceCampaignLastSent, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dir", r.sortDir, "")
	}
	if r.hasEcommerceStore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_ecommerce_store", r.hasEcommerceStore, "")
	}
	if r.includeTotalContacts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_total_contacts", r.includeTotalContacts, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	fields *[]string
	excludeFields *[]string
	includeTotalContacts *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdRequest) Fields(fields []string) ListsAPIGetListsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

// Return the total_contacts field in the stats response, which contains an approximate count of all contacts in any state.
func (r ListsAPIGetListsIdRequest) IncludeTotalContacts(includeTotalContacts bool) ListsAPIGetListsIdRequest {
	r.includeTotalContacts = &includeTotalContacts
	return r
}

func (r ListsAPIGetListsIdRequest) Execute() (*SubscriberList, *http.Response, error) {
	return r.ApiService.GetListsIdExecute(r)
}

/*
GetListsId Get list info

Get information about a specific list in your Mailchimp account. Results include list members who have signed up but haven't confirmed their subscription yet and unsubscribed or cleaned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdRequest
*/
func (a *ListsAPIService) GetListsId(ctx context.Context, listId string) ListsAPIGetListsIdRequest {
	return ListsAPIGetListsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return SubscriberList
func (a *ListsAPIService) GetListsIdExecute(r ListsAPIGetListsIdRequest) (*SubscriberList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.includeTotalContacts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_total_contacts", r.includeTotalContacts, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdAbuseReportsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdAbuseReportsRequest) Fields(fields []string) ListsAPIGetListsIdAbuseReportsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdAbuseReportsRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdAbuseReportsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdAbuseReportsRequest) Count(count int32) ListsAPIGetListsIdAbuseReportsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdAbuseReportsRequest) Offset(offset int32) ListsAPIGetListsIdAbuseReportsRequest {
	r.offset = &offset
	return r
}

func (r ListsAPIGetListsIdAbuseReportsRequest) Execute() (*AbuseComplaints, *http.Response, error) {
	return r.ApiService.GetListsIdAbuseReportsExecute(r)
}

/*
GetListsIdAbuseReports List abuse reports

Get all abuse reports for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdAbuseReportsRequest
*/
func (a *ListsAPIService) GetListsIdAbuseReports(ctx context.Context, listId string) ListsAPIGetListsIdAbuseReportsRequest {
	return ListsAPIGetListsIdAbuseReportsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return AbuseComplaints
func (a *ListsAPIService) GetListsIdAbuseReportsExecute(r ListsAPIGetListsIdAbuseReportsRequest) (*AbuseComplaints, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbuseComplaints
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdAbuseReports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/abuse-reports"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdAbuseReportsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	reportId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdAbuseReportsIdRequest) Fields(fields []string) ListsAPIGetListsIdAbuseReportsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdAbuseReportsIdRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdAbuseReportsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdAbuseReportsIdRequest) Count(count int32) ListsAPIGetListsIdAbuseReportsIdRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdAbuseReportsIdRequest) Offset(offset int32) ListsAPIGetListsIdAbuseReportsIdRequest {
	r.offset = &offset
	return r
}

func (r ListsAPIGetListsIdAbuseReportsIdRequest) Execute() (*AbuseComplaint, *http.Response, error) {
	return r.ApiService.GetListsIdAbuseReportsIdExecute(r)
}

/*
GetListsIdAbuseReportsId Get abuse report

Get details about a specific abuse report.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param reportId The id for the abuse report.
 @return ListsAPIGetListsIdAbuseReportsIdRequest
*/
func (a *ListsAPIService) GetListsIdAbuseReportsId(ctx context.Context, listId string, reportId string) ListsAPIGetListsIdAbuseReportsIdRequest {
	return ListsAPIGetListsIdAbuseReportsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		reportId: reportId,
	}
}

// Execute executes the request
//  @return AbuseComplaint
func (a *ListsAPIService) GetListsIdAbuseReportsIdExecute(r ListsAPIGetListsIdAbuseReportsIdRequest) (*AbuseComplaint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbuseComplaint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdAbuseReportsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/abuse-reports/{report_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"report_id"+"}", url.PathEscape(parameterValueToString(r.reportId, "reportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdActivityRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	count *int32
	offset *int32
	fields *[]string
	excludeFields *[]string
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdActivityRequest) Count(count int32) ListsAPIGetListsIdActivityRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdActivityRequest) Offset(offset int32) ListsAPIGetListsIdActivityRequest {
	r.offset = &offset
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdActivityRequest) Fields(fields []string) ListsAPIGetListsIdActivityRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdActivityRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdActivityRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdActivityRequest) Execute() (*ListActivity, *http.Response, error) {
	return r.ApiService.GetListsIdActivityExecute(r)
}

/*
GetListsIdActivity List recent activity

Get up to the previous 180 days of daily detailed aggregated activity stats for a list, not including Automation activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdActivityRequest
*/
func (a *ListsAPIService) GetListsIdActivity(ctx context.Context, listId string) ListsAPIGetListsIdActivityRequest {
	return ListsAPIGetListsIdActivityRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListActivity
func (a *ListsAPIService) GetListsIdActivityExecute(r ListsAPIGetListsIdActivityRequest) (*ListActivity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListActivity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/activity"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdClientsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdClientsRequest) Fields(fields []string) ListsAPIGetListsIdClientsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdClientsRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdClientsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdClientsRequest) Execute() (*EmailClients, *http.Response, error) {
	return r.ApiService.GetListsIdClientsExecute(r)
}

/*
GetListsIdClients List top email clients

Get a list of the top email clients based on user-agent strings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdClientsRequest
*/
func (a *ListsAPIService) GetListsIdClients(ctx context.Context, listId string) ListsAPIGetListsIdClientsRequest {
	return ListsAPIGetListsIdClientsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return EmailClients
func (a *ListsAPIService) GetListsIdClientsExecute(r ListsAPIGetListsIdClientsRequest) (*EmailClients, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmailClients
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdGrowthHistoryRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	sortField *string
	sortDir *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdGrowthHistoryRequest) Fields(fields []string) ListsAPIGetListsIdGrowthHistoryRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdGrowthHistoryRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdGrowthHistoryRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdGrowthHistoryRequest) Count(count int32) ListsAPIGetListsIdGrowthHistoryRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdGrowthHistoryRequest) Offset(offset int32) ListsAPIGetListsIdGrowthHistoryRequest {
	r.offset = &offset
	return r
}

// Returns files sorted by the specified field.
func (r ListsAPIGetListsIdGrowthHistoryRequest) SortField(sortField string) ListsAPIGetListsIdGrowthHistoryRequest {
	r.sortField = &sortField
	return r
}

// Determines the order direction for sorted results.
func (r ListsAPIGetListsIdGrowthHistoryRequest) SortDir(sortDir string) ListsAPIGetListsIdGrowthHistoryRequest {
	r.sortDir = &sortDir
	return r
}

func (r ListsAPIGetListsIdGrowthHistoryRequest) Execute() (*GrowthHistory, *http.Response, error) {
	return r.ApiService.GetListsIdGrowthHistoryExecute(r)
}

/*
GetListsIdGrowthHistory List growth history data

Get a month-by-month summary of a specific list's growth activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdGrowthHistoryRequest
*/
func (a *ListsAPIService) GetListsIdGrowthHistory(ctx context.Context, listId string) ListsAPIGetListsIdGrowthHistoryRequest {
	return ListsAPIGetListsIdGrowthHistoryRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return GrowthHistory
func (a *ListsAPIService) GetListsIdGrowthHistoryExecute(r ListsAPIGetListsIdGrowthHistoryRequest) (*GrowthHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GrowthHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdGrowthHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/growth-history"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dir", r.sortDir, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdGrowthHistoryIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	month string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdGrowthHistoryIdRequest) Fields(fields []string) ListsAPIGetListsIdGrowthHistoryIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdGrowthHistoryIdRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdGrowthHistoryIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdGrowthHistoryIdRequest) Execute() (*GrowthHistory, *http.Response, error) {
	return r.ApiService.GetListsIdGrowthHistoryIdExecute(r)
}

/*
GetListsIdGrowthHistoryId Get growth history by month

Get a summary of a specific list's growth activity for a specific month and year.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param month A specific month of list growth history.
 @return ListsAPIGetListsIdGrowthHistoryIdRequest
*/
func (a *ListsAPIService) GetListsIdGrowthHistoryId(ctx context.Context, listId string, month string) ListsAPIGetListsIdGrowthHistoryIdRequest {
	return ListsAPIGetListsIdGrowthHistoryIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		month: month,
	}
}

// Execute executes the request
//  @return GrowthHistory
func (a *ListsAPIService) GetListsIdGrowthHistoryIdExecute(r ListsAPIGetListsIdGrowthHistoryIdRequest) (*GrowthHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GrowthHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdGrowthHistoryId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/growth-history/{month}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"month"+"}", url.PathEscape(parameterValueToString(r.month, "month")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdInterestCategoriesRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	type_ *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdInterestCategoriesRequest) Fields(fields []string) ListsAPIGetListsIdInterestCategoriesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdInterestCategoriesRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdInterestCategoriesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdInterestCategoriesRequest) Count(count int32) ListsAPIGetListsIdInterestCategoriesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdInterestCategoriesRequest) Offset(offset int32) ListsAPIGetListsIdInterestCategoriesRequest {
	r.offset = &offset
	return r
}

// Restrict results a type of interest group
func (r ListsAPIGetListsIdInterestCategoriesRequest) Type_(type_ string) ListsAPIGetListsIdInterestCategoriesRequest {
	r.type_ = &type_
	return r
}

func (r ListsAPIGetListsIdInterestCategoriesRequest) Execute() (*InterestGroupings, *http.Response, error) {
	return r.ApiService.GetListsIdInterestCategoriesExecute(r)
}

/*
GetListsIdInterestCategories List interest categories

Get information about a list's interest categories.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdInterestCategoriesRequest
*/
func (a *ListsAPIService) GetListsIdInterestCategories(ctx context.Context, listId string) ListsAPIGetListsIdInterestCategoriesRequest {
	return ListsAPIGetListsIdInterestCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return InterestGroupings
func (a *ListsAPIService) GetListsIdInterestCategoriesExecute(r ListsAPIGetListsIdInterestCategoriesRequest) (*InterestGroupings, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterestGroupings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdInterestCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdInterestCategoriesIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	interestCategoryId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdInterestCategoriesIdRequest) Fields(fields []string) ListsAPIGetListsIdInterestCategoriesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdInterestCategoriesIdRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdInterestCategoriesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdInterestCategoriesIdRequest) Execute() (*InterestCategory, *http.Response, error) {
	return r.ApiService.GetListsIdInterestCategoriesIdExecute(r)
}

/*
GetListsIdInterestCategoriesId Get interest category info

Get information about a specific interest category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ListsAPIGetListsIdInterestCategoriesIdRequest
*/
func (a *ListsAPIService) GetListsIdInterestCategoriesId(ctx context.Context, listId string, interestCategoryId string) ListsAPIGetListsIdInterestCategoriesIdRequest {
	return ListsAPIGetListsIdInterestCategoriesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
//  @return InterestCategory
func (a *ListsAPIService) GetListsIdInterestCategoriesIdExecute(r ListsAPIGetListsIdInterestCategoriesIdRequest) (*InterestCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterestCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdInterestCategoriesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdInterestCategoriesIdInterestsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	interestCategoryId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdInterestCategoriesIdInterestsRequest) Fields(fields []string) ListsAPIGetListsIdInterestCategoriesIdInterestsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdInterestCategoriesIdInterestsRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdInterestCategoriesIdInterestsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdInterestCategoriesIdInterestsRequest) Count(count int32) ListsAPIGetListsIdInterestCategoriesIdInterestsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdInterestCategoriesIdInterestsRequest) Offset(offset int32) ListsAPIGetListsIdInterestCategoriesIdInterestsRequest {
	r.offset = &offset
	return r
}

func (r ListsAPIGetListsIdInterestCategoriesIdInterestsRequest) Execute() (*Interests, *http.Response, error) {
	return r.ApiService.GetListsIdInterestCategoriesIdInterestsExecute(r)
}

/*
GetListsIdInterestCategoriesIdInterests List interests in category

Get a list of this category's interests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ListsAPIGetListsIdInterestCategoriesIdInterestsRequest
*/
func (a *ListsAPIService) GetListsIdInterestCategoriesIdInterests(ctx context.Context, listId string, interestCategoryId string) ListsAPIGetListsIdInterestCategoriesIdInterestsRequest {
	return ListsAPIGetListsIdInterestCategoriesIdInterestsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
//  @return Interests
func (a *ListsAPIService) GetListsIdInterestCategoriesIdInterestsExecute(r ListsAPIGetListsIdInterestCategoriesIdInterestsRequest) (*Interests, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interests
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdInterestCategoriesIdInterests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	interestCategoryId string
	interestId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest) Fields(fields []string) ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest) Execute() (*Interest, *http.Response, error) {
	return r.ApiService.GetListsIdInterestCategoriesIdInterestsIdExecute(r)
}

/*
GetListsIdInterestCategoriesIdInterestsId Get interest in category

Get interests or 'group names' for a specific category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @param interestId The specific interest or 'group name'.
 @return ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest
*/
func (a *ListsAPIService) GetListsIdInterestCategoriesIdInterestsId(ctx context.Context, listId string, interestCategoryId string, interestId string) ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest {
	return ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
		interestId: interestId,
	}
}

// Execute executes the request
//  @return Interest
func (a *ListsAPIService) GetListsIdInterestCategoriesIdInterestsIdExecute(r ListsAPIGetListsIdInterestCategoriesIdInterestsIdRequest) (*Interest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdInterestCategoriesIdInterestsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_id"+"}", url.PathEscape(parameterValueToString(r.interestId, "interestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdLocationsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdLocationsRequest) Fields(fields []string) ListsAPIGetListsIdLocationsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdLocationsRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdLocationsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdLocationsRequest) Execute() (*ListLocations, *http.Response, error) {
	return r.ApiService.GetListsIdLocationsExecute(r)
}

/*
GetListsIdLocations List locations

Get the locations (countries) that the list's subscribers have been tagged to based on geocoding their IP address.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdLocationsRequest
*/
func (a *ListsAPIService) GetListsIdLocations(ctx context.Context, listId string) ListsAPIGetListsIdLocationsRequest {
	return ListsAPIGetListsIdLocationsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListLocations
func (a *ListsAPIService) GetListsIdLocationsExecute(r ListsAPIGetListsIdLocationsRequest) (*ListLocations, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListLocations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdLocations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/locations"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMembersRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	emailType *string
	status *string
	sinceTimestampOpt *string
	beforeTimestampOpt *string
	sinceLastChanged *string
	beforeLastChanged *string
	uniqueEmailId *string
	vipOnly *bool
	interestCategoryId *string
	interestIds *string
	interestMatch *string
	sortField *string
	sortDir *string
	sinceLastCampaign *bool
	unsubscribedSince *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersRequest) Fields(fields []string) ListsAPIGetListsIdMembersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMembersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdMembersRequest) Count(count int32) ListsAPIGetListsIdMembersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdMembersRequest) Offset(offset int32) ListsAPIGetListsIdMembersRequest {
	r.offset = &offset
	return r
}

// The email type.
func (r ListsAPIGetListsIdMembersRequest) EmailType(emailType string) ListsAPIGetListsIdMembersRequest {
	r.emailType = &emailType
	return r
}

// The subscriber&#39;s status.
func (r ListsAPIGetListsIdMembersRequest) Status(status string) ListsAPIGetListsIdMembersRequest {
	r.status = &status
	return r
}

// Restrict results to subscribers who opted-in after the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIGetListsIdMembersRequest) SinceTimestampOpt(sinceTimestampOpt string) ListsAPIGetListsIdMembersRequest {
	r.sinceTimestampOpt = &sinceTimestampOpt
	return r
}

// Restrict results to subscribers who opted-in before the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIGetListsIdMembersRequest) BeforeTimestampOpt(beforeTimestampOpt string) ListsAPIGetListsIdMembersRequest {
	r.beforeTimestampOpt = &beforeTimestampOpt
	return r
}

// Restrict results to subscribers whose information changed after the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIGetListsIdMembersRequest) SinceLastChanged(sinceLastChanged string) ListsAPIGetListsIdMembersRequest {
	r.sinceLastChanged = &sinceLastChanged
	return r
}

// Restrict results to subscribers whose information changed before the set timeframe. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIGetListsIdMembersRequest) BeforeLastChanged(beforeLastChanged string) ListsAPIGetListsIdMembersRequest {
	r.beforeLastChanged = &beforeLastChanged
	return r
}

// A unique identifier for the email address across all Mailchimp lists.
func (r ListsAPIGetListsIdMembersRequest) UniqueEmailId(uniqueEmailId string) ListsAPIGetListsIdMembersRequest {
	r.uniqueEmailId = &uniqueEmailId
	return r
}

// A filter to return only the list&#39;s VIP members. Passing &#x60;true&#x60; will restrict results to VIP list members, passing &#x60;false&#x60; will return all list members.
func (r ListsAPIGetListsIdMembersRequest) VipOnly(vipOnly bool) ListsAPIGetListsIdMembersRequest {
	r.vipOnly = &vipOnly
	return r
}

// The unique id for the interest category.
func (r ListsAPIGetListsIdMembersRequest) InterestCategoryId(interestCategoryId string) ListsAPIGetListsIdMembersRequest {
	r.interestCategoryId = &interestCategoryId
	return r
}

// Used to filter list members by interests. Must be accompanied by interest_category_id and interest_match. The value must be a comma separated list of interest ids present for any supplied interest categories.
func (r ListsAPIGetListsIdMembersRequest) InterestIds(interestIds string) ListsAPIGetListsIdMembersRequest {
	r.interestIds = &interestIds
	return r
}

// Used to filter list members by interests. Must be accompanied by interest_category_id and interest_ids. \&quot;any\&quot; will match a member with any of the interest supplied, \&quot;all\&quot; will only match members with every interest supplied, and \&quot;none\&quot; will match members without any of the interest supplied.
func (r ListsAPIGetListsIdMembersRequest) InterestMatch(interestMatch string) ListsAPIGetListsIdMembersRequest {
	r.interestMatch = &interestMatch
	return r
}

// Returns files sorted by the specified field.
func (r ListsAPIGetListsIdMembersRequest) SortField(sortField string) ListsAPIGetListsIdMembersRequest {
	r.sortField = &sortField
	return r
}

// Determines the order direction for sorted results.
func (r ListsAPIGetListsIdMembersRequest) SortDir(sortDir string) ListsAPIGetListsIdMembersRequest {
	r.sortDir = &sortDir
	return r
}

// Filter subscribers by those subscribed/unsubscribed/pending/cleaned since last email campaign send. Member status is required to use this filter.
func (r ListsAPIGetListsIdMembersRequest) SinceLastCampaign(sinceLastCampaign bool) ListsAPIGetListsIdMembersRequest {
	r.sinceLastCampaign = &sinceLastCampaign
	return r
}

// Filter subscribers by those unsubscribed since a specific date. Using any status other than unsubscribed with this filter will result in an error.
func (r ListsAPIGetListsIdMembersRequest) UnsubscribedSince(unsubscribedSince string) ListsAPIGetListsIdMembersRequest {
	r.unsubscribedSince = &unsubscribedSince
	return r
}

func (r ListsAPIGetListsIdMembersRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.GetListsIdMembersExecute(r)
}

/*
GetListsIdMembers List members info

Get information about members in a specific Mailchimp list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdMembersRequest
*/
func (a *ListsAPIService) GetListsIdMembers(ctx context.Context, listId string) ListsAPIGetListsIdMembersRequest {
	return ListsAPIGetListsIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) GetListsIdMembersExecute(r ListsAPIGetListsIdMembersRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.emailType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email_type", r.emailType, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.sinceTimestampOpt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_timestamp_opt", r.sinceTimestampOpt, "")
	}
	if r.beforeTimestampOpt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_timestamp_opt", r.beforeTimestampOpt, "")
	}
	if r.sinceLastChanged != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_last_changed", r.sinceLastChanged, "")
	}
	if r.beforeLastChanged != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_last_changed", r.beforeLastChanged, "")
	}
	if r.uniqueEmailId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unique_email_id", r.uniqueEmailId, "")
	}
	if r.vipOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vip_only", r.vipOnly, "")
	}
	if r.interestCategoryId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interest_category_id", r.interestCategoryId, "")
	}
	if r.interestIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interest_ids", r.interestIds, "")
	}
	if r.interestMatch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interest_match", r.interestMatch, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dir", r.sortDir, "")
	}
	if r.sinceLastCampaign != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_last_campaign", r.sinceLastCampaign, "")
	}
	if r.unsubscribedSince != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unsubscribed_since", r.unsubscribedSince, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMembersIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdRequest) Fields(fields []string) ListsAPIGetListsIdMembersIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMembersIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdMembersIdRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdExecute(r)
}

/*
GetListsIdMembersId Get member info

Get information about a specific list member, including a currently subscribed, unsubscribed, or bounced member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIGetListsIdMembersIdRequest
*/
func (a *ListsAPIService) GetListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdRequest {
	return ListsAPIGetListsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) GetListsIdMembersIdExecute(r ListsAPIGetListsIdMembersIdRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMembersIdActivityRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
	action *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdActivityRequest) Fields(fields []string) ListsAPIGetListsIdMembersIdActivityRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdActivityRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMembersIdActivityRequest {
	r.excludeFields = &excludeFields
	return r
}

// A comma seperated list of actions to return.
func (r ListsAPIGetListsIdMembersIdActivityRequest) Action(action []string) ListsAPIGetListsIdMembersIdActivityRequest {
	r.action = &action
	return r
}

func (r ListsAPIGetListsIdMembersIdActivityRequest) Execute() (*MemberActivityEvents, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdActivityExecute(r)
}

/*
GetListsIdMembersIdActivity View recent activity 50

Get the last 50 events of a member's activity on a specific list, including opens, clicks, and unsubscribes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIGetListsIdMembersIdActivityRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdActivity(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdActivityRequest {
	return ListsAPIGetListsIdMembersIdActivityRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return MemberActivityEvents
func (a *ListsAPIService) GetListsIdMembersIdActivityExecute(r ListsAPIGetListsIdMembersIdActivityRequest) (*MemberActivityEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberActivityEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdActivity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/activity"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMembersIdActivityFeedRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	activityFilters *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdActivityFeedRequest) Fields(fields []string) ListsAPIGetListsIdMembersIdActivityFeedRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdActivityFeedRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMembersIdActivityFeedRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdMembersIdActivityFeedRequest) Count(count int32) ListsAPIGetListsIdMembersIdActivityFeedRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdMembersIdActivityFeedRequest) Offset(offset int32) ListsAPIGetListsIdMembersIdActivityFeedRequest {
	r.offset = &offset
	return r
}

// A comma-separated list of activity filters that correspond to a set of activity types, e.g \&quot;?activity_filters&#x3D;open,bounce,click\&quot;.
func (r ListsAPIGetListsIdMembersIdActivityFeedRequest) ActivityFilters(activityFilters []string) ListsAPIGetListsIdMembersIdActivityFeedRequest {
	r.activityFilters = &activityFilters
	return r
}

func (r ListsAPIGetListsIdMembersIdActivityFeedRequest) Execute() (*MemberActivityEvents1, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdActivityFeedExecute(r)
}

/*
GetListsIdMembersIdActivityFeed View recent activity

Get a member's activity on a specific list, including opens, clicks, and unsubscribes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIGetListsIdMembersIdActivityFeedRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdActivityFeed(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdActivityFeedRequest {
	return ListsAPIGetListsIdMembersIdActivityFeedRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return MemberActivityEvents1
func (a *ListsAPIService) GetListsIdMembersIdActivityFeedExecute(r ListsAPIGetListsIdMembersIdActivityFeedRequest) (*MemberActivityEvents1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberActivityEvents1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdActivityFeed")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/activity-feed"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.activityFilters != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activity_filters", r.activityFilters, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMembersIdEventsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	count *int32
	offset *int32
	fields *[]string
	excludeFields *[]string
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdMembersIdEventsRequest) Count(count int32) ListsAPIGetListsIdMembersIdEventsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdMembersIdEventsRequest) Offset(offset int32) ListsAPIGetListsIdMembersIdEventsRequest {
	r.offset = &offset
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdEventsRequest) Fields(fields []string) ListsAPIGetListsIdMembersIdEventsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdEventsRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMembersIdEventsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdMembersIdEventsRequest) Execute() (*CollectionOfEvents, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdEventsExecute(r)
}

/*
GetListsIdMembersIdEvents List member events

Get events for a contact.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIGetListsIdMembersIdEventsRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdEvents(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdEventsRequest {
	return ListsAPIGetListsIdMembersIdEventsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return CollectionOfEvents
func (a *ListsAPIService) GetListsIdMembersIdEventsExecute(r ListsAPIGetListsIdMembersIdEventsRequest) (*CollectionOfEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMembersIdGoalsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdGoalsRequest) Fields(fields []string) ListsAPIGetListsIdMembersIdGoalsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdGoalsRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMembersIdGoalsRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdMembersIdGoalsRequest) Execute() (*CollectionOfMemberActivityEvents, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdGoalsExecute(r)
}

/*
GetListsIdMembersIdGoals List member goal events

Get the last 50 Goal events for a member on a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIGetListsIdMembersIdGoalsRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdGoals(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdGoalsRequest {
	return ListsAPIGetListsIdMembersIdGoalsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return CollectionOfMemberActivityEvents
func (a *ListsAPIService) GetListsIdMembersIdGoalsExecute(r ListsAPIGetListsIdMembersIdGoalsRequest) (*CollectionOfMemberActivityEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfMemberActivityEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdGoals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/goals"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMembersIdNotesRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	sortField *string
	sortDir *string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
}

// Returns notes sorted by the specified field.
func (r ListsAPIGetListsIdMembersIdNotesRequest) SortField(sortField string) ListsAPIGetListsIdMembersIdNotesRequest {
	r.sortField = &sortField
	return r
}

// Determines the order direction for sorted results.
func (r ListsAPIGetListsIdMembersIdNotesRequest) SortDir(sortDir string) ListsAPIGetListsIdMembersIdNotesRequest {
	r.sortDir = &sortDir
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdNotesRequest) Fields(fields []string) ListsAPIGetListsIdMembersIdNotesRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdNotesRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMembersIdNotesRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdMembersIdNotesRequest) Count(count int32) ListsAPIGetListsIdMembersIdNotesRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdMembersIdNotesRequest) Offset(offset int32) ListsAPIGetListsIdMembersIdNotesRequest {
	r.offset = &offset
	return r
}

func (r ListsAPIGetListsIdMembersIdNotesRequest) Execute() (*CollectionOfNotes, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdNotesExecute(r)
}

/*
GetListsIdMembersIdNotes List recent member notes

Get recent notes for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ListsAPIGetListsIdMembersIdNotesRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdNotes(ctx context.Context, listId string, subscriberHash string) ListsAPIGetListsIdMembersIdNotesRequest {
	return ListsAPIGetListsIdMembersIdNotesRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return CollectionOfNotes
func (a *ListsAPIService) GetListsIdMembersIdNotesExecute(r ListsAPIGetListsIdMembersIdNotesRequest) (*CollectionOfNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortDir != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dir", r.sortDir, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMembersIdNotesIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	noteId string
	fields *[]string
	excludeFields *[]string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdNotesIdRequest) Fields(fields []string) ListsAPIGetListsIdMembersIdNotesIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMembersIdNotesIdRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMembersIdNotesIdRequest {
	r.excludeFields = &excludeFields
	return r
}

func (r ListsAPIGetListsIdMembersIdNotesIdRequest) Execute() (*MemberNotes, *http.Response, error) {
	return r.ApiService.GetListsIdMembersIdNotesIdExecute(r)
}

/*
GetListsIdMembersIdNotesId Get member note

Get a specific note for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @param noteId The id for the note.
 @return ListsAPIGetListsIdMembersIdNotesIdRequest
*/
func (a *ListsAPIService) GetListsIdMembersIdNotesId(ctx context.Context, listId string, subscriberHash string, noteId string) ListsAPIGetListsIdMembersIdNotesIdRequest {
	return ListsAPIGetListsIdMembersIdNotesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
		noteId: noteId,
	}
}

// Execute executes the request
//  @return MemberNotes
func (a *ListsAPIService) GetListsIdMembersIdNotesIdExecute(r ListsAPIGetListsIdMembersIdNotesIdRequest) (*MemberNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMembersIdNotesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"note_id"+"}", url.PathEscape(parameterValueToString(r.noteId, "noteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMergeFieldsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	type_ *string
	required *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMergeFieldsRequest) Fields(fields []string) ListsAPIGetListsIdMergeFieldsRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMergeFieldsRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMergeFieldsRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdMergeFieldsRequest) Count(count int32) ListsAPIGetListsIdMergeFieldsRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdMergeFieldsRequest) Offset(offset int32) ListsAPIGetListsIdMergeFieldsRequest {
	r.offset = &offset
	return r
}

// The merge field type.
func (r ListsAPIGetListsIdMergeFieldsRequest) Type_(type_ string) ListsAPIGetListsIdMergeFieldsRequest {
	r.type_ = &type_
	return r
}

// Whether it&#39;s a required merge field.
func (r ListsAPIGetListsIdMergeFieldsRequest) Required(required bool) ListsAPIGetListsIdMergeFieldsRequest {
	r.required = &required
	return r
}

func (r ListsAPIGetListsIdMergeFieldsRequest) Execute() (*CollectionOfMergeFields, *http.Response, error) {
	return r.ApiService.GetListsIdMergeFieldsExecute(r)
}

/*
GetListsIdMergeFields List merge fields

Get a list of all merge fields for an audience.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdMergeFieldsRequest
*/
func (a *ListsAPIService) GetListsIdMergeFields(ctx context.Context, listId string) ListsAPIGetListsIdMergeFieldsRequest {
	return ListsAPIGetListsIdMergeFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return CollectionOfMergeFields
func (a *ListsAPIService) GetListsIdMergeFieldsExecute(r ListsAPIGetListsIdMergeFieldsRequest) (*CollectionOfMergeFields, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfMergeFields
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMergeFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.required != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "required", r.required, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdMergeFieldsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	mergeId string
	excludeFields *[]string
	fields *[]string
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMergeFieldsIdRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdMergeFieldsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdMergeFieldsIdRequest) Fields(fields []string) ListsAPIGetListsIdMergeFieldsIdRequest {
	r.fields = &fields
	return r
}

func (r ListsAPIGetListsIdMergeFieldsIdRequest) Execute() (*MergeField, *http.Response, error) {
	return r.ApiService.GetListsIdMergeFieldsIdExecute(r)
}

/*
GetListsIdMergeFieldsId Get merge field

Get information about a specific merge field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param mergeId The id for the merge field.
 @return ListsAPIGetListsIdMergeFieldsIdRequest
*/
func (a *ListsAPIService) GetListsIdMergeFieldsId(ctx context.Context, listId string, mergeId string) ListsAPIGetListsIdMergeFieldsIdRequest {
	return ListsAPIGetListsIdMergeFieldsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		mergeId: mergeId,
	}
}

// Execute executes the request
//  @return MergeField
func (a *ListsAPIService) GetListsIdMergeFieldsIdExecute(r ListsAPIGetListsIdMergeFieldsIdRequest) (*MergeField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdMergeFieldsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields/{merge_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_id"+"}", url.PathEscape(parameterValueToString(r.mergeId, "mergeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdSegmentsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	segmentId string
	fields *[]string
	excludeFields *[]string
	includeCleaned *bool
	includeTransactional *bool
	includeUnsubscribed *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdSegmentsIdRequest) Fields(fields []string) ListsAPIGetListsIdSegmentsIdRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdSegmentsIdRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdSegmentsIdRequest {
	r.excludeFields = &excludeFields
	return r
}

// Include cleaned members in response
func (r ListsAPIGetListsIdSegmentsIdRequest) IncludeCleaned(includeCleaned bool) ListsAPIGetListsIdSegmentsIdRequest {
	r.includeCleaned = &includeCleaned
	return r
}

// Include transactional members in response
func (r ListsAPIGetListsIdSegmentsIdRequest) IncludeTransactional(includeTransactional bool) ListsAPIGetListsIdSegmentsIdRequest {
	r.includeTransactional = &includeTransactional
	return r
}

// Include unsubscribed members in response
func (r ListsAPIGetListsIdSegmentsIdRequest) IncludeUnsubscribed(includeUnsubscribed bool) ListsAPIGetListsIdSegmentsIdRequest {
	r.includeUnsubscribed = &includeUnsubscribed
	return r
}

func (r ListsAPIGetListsIdSegmentsIdRequest) Execute() (*List7, *http.Response, error) {
	return r.ApiService.GetListsIdSegmentsIdExecute(r)
}

/*
GetListsIdSegmentsId Get segment info

Get information about a specific segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ListsAPIGetListsIdSegmentsIdRequest
*/
func (a *ListsAPIService) GetListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ListsAPIGetListsIdSegmentsIdRequest {
	return ListsAPIGetListsIdSegmentsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return List7
func (a *ListsAPIService) GetListsIdSegmentsIdExecute(r ListsAPIGetListsIdSegmentsIdRequest) (*List7, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *List7
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSegmentsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.includeCleaned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_cleaned", r.includeCleaned, "")
	}
	if r.includeTransactional != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_transactional", r.includeTransactional, "")
	}
	if r.includeUnsubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unsubscribed", r.includeUnsubscribed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdSegmentsIdMembersRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	segmentId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	includeCleaned *bool
	includeTransactional *bool
	includeUnsubscribed *bool
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdSegmentsIdMembersRequest) Fields(fields []string) ListsAPIGetListsIdSegmentsIdMembersRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIGetListsIdSegmentsIdMembersRequest) ExcludeFields(excludeFields []string) ListsAPIGetListsIdSegmentsIdMembersRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIGetListsIdSegmentsIdMembersRequest) Count(count int32) ListsAPIGetListsIdSegmentsIdMembersRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIGetListsIdSegmentsIdMembersRequest) Offset(offset int32) ListsAPIGetListsIdSegmentsIdMembersRequest {
	r.offset = &offset
	return r
}

// Include cleaned members in response
func (r ListsAPIGetListsIdSegmentsIdMembersRequest) IncludeCleaned(includeCleaned bool) ListsAPIGetListsIdSegmentsIdMembersRequest {
	r.includeCleaned = &includeCleaned
	return r
}

// Include transactional members in response
func (r ListsAPIGetListsIdSegmentsIdMembersRequest) IncludeTransactional(includeTransactional bool) ListsAPIGetListsIdSegmentsIdMembersRequest {
	r.includeTransactional = &includeTransactional
	return r
}

// Include unsubscribed members in response
func (r ListsAPIGetListsIdSegmentsIdMembersRequest) IncludeUnsubscribed(includeUnsubscribed bool) ListsAPIGetListsIdSegmentsIdMembersRequest {
	r.includeUnsubscribed = &includeUnsubscribed
	return r
}

func (r ListsAPIGetListsIdSegmentsIdMembersRequest) Execute() (*SegmentMembers, *http.Response, error) {
	return r.ApiService.GetListsIdSegmentsIdMembersExecute(r)
}

/*
GetListsIdSegmentsIdMembers List members in segment

Get information about members in a saved segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ListsAPIGetListsIdSegmentsIdMembersRequest
*/
func (a *ListsAPIService) GetListsIdSegmentsIdMembers(ctx context.Context, listId string, segmentId string) ListsAPIGetListsIdSegmentsIdMembersRequest {
	return ListsAPIGetListsIdSegmentsIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return SegmentMembers
func (a *ListsAPIService) GetListsIdSegmentsIdMembersExecute(r ListsAPIGetListsIdSegmentsIdMembersRequest) (*SegmentMembers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SegmentMembers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSegmentsIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.includeCleaned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_cleaned", r.includeCleaned, "")
	}
	if r.includeTransactional != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_transactional", r.includeTransactional, "")
	}
	if r.includeUnsubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unsubscribed", r.includeUnsubscribed, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdSignupFormsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
}

func (r ListsAPIGetListsIdSignupFormsRequest) Execute() (*ListSignupForms, *http.Response, error) {
	return r.ApiService.GetListsIdSignupFormsExecute(r)
}

/*
GetListsIdSignupForms List signup forms

Get signup forms for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdSignupFormsRequest
*/
func (a *ListsAPIService) GetListsIdSignupForms(ctx context.Context, listId string) ListsAPIGetListsIdSignupFormsRequest {
	return ListsAPIGetListsIdSignupFormsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListSignupForms
func (a *ListsAPIService) GetListsIdSignupFormsExecute(r ListsAPIGetListsIdSignupFormsRequest) (*ListSignupForms, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListSignupForms
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSignupForms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/signup-forms"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdSurveysRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
}

func (r ListsAPIGetListsIdSurveysRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetListsIdSurveysExecute(r)
}

/*
GetListsIdSurveys Get information about all surveys for a list

Get information about all available surveys for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdSurveysRequest
*/
func (a *ListsAPIService) GetListsIdSurveys(ctx context.Context, listId string) ListsAPIGetListsIdSurveysRequest {
	return ListsAPIGetListsIdSurveysRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
func (a *ListsAPIService) GetListsIdSurveysExecute(r ListsAPIGetListsIdSurveysRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSurveys")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/surveys"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIGetListsIdSurveysIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	surveyId string
}

func (r ListsAPIGetListsIdSurveysIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetListsIdSurveysIdExecute(r)
}

/*
GetListsIdSurveysId Get survey

Get details about a specific survey.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param surveyId The ID of the survey.
 @return ListsAPIGetListsIdSurveysIdRequest
*/
func (a *ListsAPIService) GetListsIdSurveysId(ctx context.Context, listId string, surveyId string) ListsAPIGetListsIdSurveysIdRequest {
	return ListsAPIGetListsIdSurveysIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		surveyId: surveyId,
	}
}

// Execute executes the request
func (a *ListsAPIService) GetListsIdSurveysIdExecute(r ListsAPIGetListsIdSurveysIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdSurveysId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/surveys/{survey_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"survey_id"+"}", url.PathEscape(parameterValueToString(r.surveyId, "surveyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIGetListsIdWebhooksRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
}

func (r ListsAPIGetListsIdWebhooksRequest) Execute() (*ListWebhooks, *http.Response, error) {
	return r.ApiService.GetListsIdWebhooksExecute(r)
}

/*
GetListsIdWebhooks List webhooks

Get information about all webhooks for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIGetListsIdWebhooksRequest
*/
func (a *ListsAPIService) GetListsIdWebhooks(ctx context.Context, listId string) ListsAPIGetListsIdWebhooksRequest {
	return ListsAPIGetListsIdWebhooksRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListWebhooks
func (a *ListsAPIService) GetListsIdWebhooksExecute(r ListsAPIGetListsIdWebhooksRequest) (*ListWebhooks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListWebhooks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdWebhooks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIGetListsIdWebhooksIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	webhookId string
}

func (r ListsAPIGetListsIdWebhooksIdRequest) Execute() (*ListWebhooks, *http.Response, error) {
	return r.ApiService.GetListsIdWebhooksIdExecute(r)
}

/*
GetListsIdWebhooksId Get webhook info

Get information about a specific webhook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param webhookId The webhook's id.
 @return ListsAPIGetListsIdWebhooksIdRequest
*/
func (a *ListsAPIService) GetListsIdWebhooksId(ctx context.Context, listId string, webhookId string) ListsAPIGetListsIdWebhooksIdRequest {
	return ListsAPIGetListsIdWebhooksIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		webhookId: webhookId,
	}
}

// Execute executes the request
//  @return ListWebhooks
func (a *ListsAPIService) GetListsIdWebhooksIdExecute(r ListsAPIGetListsIdWebhooksIdRequest) (*ListWebhooks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListWebhooks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.GetListsIdWebhooksId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks/{webhook_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhook_id"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPatchListsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	body *SubscriberList2
}

func (r ListsAPIPatchListsIdRequest) Body(body SubscriberList2) ListsAPIPatchListsIdRequest {
	r.body = &body
	return r
}

func (r ListsAPIPatchListsIdRequest) Execute() (*SubscriberList, *http.Response, error) {
	return r.ApiService.PatchListsIdExecute(r)
}

/*
PatchListsId Update lists

Update the settings for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIPatchListsIdRequest
*/
func (a *ListsAPIService) PatchListsId(ctx context.Context, listId string) ListsAPIPatchListsIdRequest {
	return ListsAPIPatchListsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return SubscriberList
func (a *ListsAPIService) PatchListsIdExecute(r ListsAPIPatchListsIdRequest) (*SubscriberList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPatchListsIdInterestCategoriesIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	interestCategoryId string
	body *InterestCategory1
}

func (r ListsAPIPatchListsIdInterestCategoriesIdRequest) Body(body InterestCategory1) ListsAPIPatchListsIdInterestCategoriesIdRequest {
	r.body = &body
	return r
}

func (r ListsAPIPatchListsIdInterestCategoriesIdRequest) Execute() (*InterestCategory, *http.Response, error) {
	return r.ApiService.PatchListsIdInterestCategoriesIdExecute(r)
}

/*
PatchListsIdInterestCategoriesId Update interest category

Update a specific interest category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ListsAPIPatchListsIdInterestCategoriesIdRequest
*/
func (a *ListsAPIService) PatchListsIdInterestCategoriesId(ctx context.Context, listId string, interestCategoryId string) ListsAPIPatchListsIdInterestCategoriesIdRequest {
	return ListsAPIPatchListsIdInterestCategoriesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
//  @return InterestCategory
func (a *ListsAPIService) PatchListsIdInterestCategoriesIdExecute(r ListsAPIPatchListsIdInterestCategoriesIdRequest) (*InterestCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterestCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdInterestCategoriesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	interestCategoryId string
	interestId string
	body *Interest1
}

func (r ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest) Body(body Interest1) ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest {
	r.body = &body
	return r
}

func (r ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest) Execute() (*Interest, *http.Response, error) {
	return r.ApiService.PatchListsIdInterestCategoriesIdInterestsIdExecute(r)
}

/*
PatchListsIdInterestCategoriesIdInterestsId Update interest in category

Update interests or 'group names' for a specific category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @param interestId The specific interest or 'group name'.
 @return ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest
*/
func (a *ListsAPIService) PatchListsIdInterestCategoriesIdInterestsId(ctx context.Context, listId string, interestCategoryId string, interestId string) ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest {
	return ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
		interestId: interestId,
	}
}

// Execute executes the request
//  @return Interest
func (a *ListsAPIService) PatchListsIdInterestCategoriesIdInterestsIdExecute(r ListsAPIPatchListsIdInterestCategoriesIdInterestsIdRequest) (*Interest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdInterestCategoriesIdInterestsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests/{interest_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_id"+"}", url.PathEscape(parameterValueToString(r.interestId, "interestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPatchListsIdMembersIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	body *AddListMembers3
	skipMergeValidation *bool
}

func (r ListsAPIPatchListsIdMembersIdRequest) Body(body AddListMembers3) ListsAPIPatchListsIdMembersIdRequest {
	r.body = &body
	return r
}

// If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
func (r ListsAPIPatchListsIdMembersIdRequest) SkipMergeValidation(skipMergeValidation bool) ListsAPIPatchListsIdMembersIdRequest {
	r.skipMergeValidation = &skipMergeValidation
	return r
}

func (r ListsAPIPatchListsIdMembersIdRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.PatchListsIdMembersIdExecute(r)
}

/*
PatchListsIdMembersId Update list member

Update information for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIPatchListsIdMembersIdRequest
*/
func (a *ListsAPIService) PatchListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ListsAPIPatchListsIdMembersIdRequest {
	return ListsAPIPatchListsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) PatchListsIdMembersIdExecute(r ListsAPIPatchListsIdMembersIdRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdMembersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.skipMergeValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_merge_validation", r.skipMergeValidation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPatchListsIdMembersIdNotesIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	noteId string
	body *MemberNotes1
}

func (r ListsAPIPatchListsIdMembersIdNotesIdRequest) Body(body MemberNotes1) ListsAPIPatchListsIdMembersIdNotesIdRequest {
	r.body = &body
	return r
}

func (r ListsAPIPatchListsIdMembersIdNotesIdRequest) Execute() (*MemberNotes, *http.Response, error) {
	return r.ApiService.PatchListsIdMembersIdNotesIdExecute(r)
}

/*
PatchListsIdMembersIdNotesId Update note

Update a specific note for a specific list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @param noteId The id for the note.
 @return ListsAPIPatchListsIdMembersIdNotesIdRequest
*/
func (a *ListsAPIService) PatchListsIdMembersIdNotesId(ctx context.Context, listId string, subscriberHash string, noteId string) ListsAPIPatchListsIdMembersIdNotesIdRequest {
	return ListsAPIPatchListsIdMembersIdNotesIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
		noteId: noteId,
	}
}

// Execute executes the request
//  @return MemberNotes
func (a *ListsAPIService) PatchListsIdMembersIdNotesIdExecute(r ListsAPIPatchListsIdMembersIdNotesIdRequest) (*MemberNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdMembersIdNotesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes/{note_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"note_id"+"}", url.PathEscape(parameterValueToString(r.noteId, "noteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPatchListsIdMergeFieldsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	mergeId string
	body *MergeField2
}

func (r ListsAPIPatchListsIdMergeFieldsIdRequest) Body(body MergeField2) ListsAPIPatchListsIdMergeFieldsIdRequest {
	r.body = &body
	return r
}

func (r ListsAPIPatchListsIdMergeFieldsIdRequest) Execute() (*MergeField, *http.Response, error) {
	return r.ApiService.PatchListsIdMergeFieldsIdExecute(r)
}

/*
PatchListsIdMergeFieldsId Update merge field

Update a specific merge field.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param mergeId The id for the merge field.
 @return ListsAPIPatchListsIdMergeFieldsIdRequest
*/
func (a *ListsAPIService) PatchListsIdMergeFieldsId(ctx context.Context, listId string, mergeId string) ListsAPIPatchListsIdMergeFieldsIdRequest {
	return ListsAPIPatchListsIdMergeFieldsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		mergeId: mergeId,
	}
}

// Execute executes the request
//  @return MergeField
func (a *ListsAPIService) PatchListsIdMergeFieldsIdExecute(r ListsAPIPatchListsIdMergeFieldsIdRequest) (*MergeField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdMergeFieldsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields/{merge_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"merge_id"+"}", url.PathEscape(parameterValueToString(r.mergeId, "mergeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPatchListsIdSegmentsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	segmentId string
	body *List9
}

func (r ListsAPIPatchListsIdSegmentsIdRequest) Body(body List9) ListsAPIPatchListsIdSegmentsIdRequest {
	r.body = &body
	return r
}

func (r ListsAPIPatchListsIdSegmentsIdRequest) Execute() (*List7, *http.Response, error) {
	return r.ApiService.PatchListsIdSegmentsIdExecute(r)
}

/*
PatchListsIdSegmentsId Update segment

Update a specific segment in a list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ListsAPIPatchListsIdSegmentsIdRequest
*/
func (a *ListsAPIService) PatchListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ListsAPIPatchListsIdSegmentsIdRequest {
	return ListsAPIPatchListsIdSegmentsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return List7
func (a *ListsAPIService) PatchListsIdSegmentsIdExecute(r ListsAPIPatchListsIdSegmentsIdRequest) (*List7, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *List7
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdSegmentsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPatchListsIdWebhooksIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	webhookId string
	body *AddWebhook
}

func (r ListsAPIPatchListsIdWebhooksIdRequest) Body(body AddWebhook) ListsAPIPatchListsIdWebhooksIdRequest {
	r.body = &body
	return r
}

func (r ListsAPIPatchListsIdWebhooksIdRequest) Execute() (*ListWebhooks, *http.Response, error) {
	return r.ApiService.PatchListsIdWebhooksIdExecute(r)
}

/*
PatchListsIdWebhooksId Update webhook

Update the settings for an existing webhook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param webhookId The webhook's id.
 @return ListsAPIPatchListsIdWebhooksIdRequest
*/
func (a *ListsAPIService) PatchListsIdWebhooksId(ctx context.Context, listId string, webhookId string) ListsAPIPatchListsIdWebhooksIdRequest {
	return ListsAPIPatchListsIdWebhooksIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		webhookId: webhookId,
	}
}

// Execute executes the request
//  @return ListWebhooks
func (a *ListsAPIService) PatchListsIdWebhooksIdExecute(r ListsAPIPatchListsIdWebhooksIdRequest) (*ListWebhooks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListWebhooks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PatchListsIdWebhooksId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks/{webhook_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"webhook_id"+"}", url.PathEscape(parameterValueToString(r.webhookId, "webhookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListMemberEventsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	body *Events
}

func (r ListsAPIPostListMemberEventsRequest) Body(body Events) ListsAPIPostListMemberEventsRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListMemberEventsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostListMemberEventsExecute(r)
}

/*
PostListMemberEvents Add event

Add an event for a list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIPostListMemberEventsRequest
*/
func (a *ListsAPIService) PostListMemberEvents(ctx context.Context, listId string, subscriberHash string) ListsAPIPostListMemberEventsRequest {
	return ListsAPIPostListMemberEventsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) PostListMemberEventsExecute(r ListsAPIPostListMemberEventsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListMemberEvents")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIPostListMemberTagsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	body *MemberTags
}

func (r ListsAPIPostListMemberTagsRequest) Body(body MemberTags) ListsAPIPostListMemberTagsRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListMemberTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostListMemberTagsExecute(r)
}

/*
PostListMemberTags Add or remove member tags

Add or remove tags from a list member. If a tag that does not exist is passed in and set as 'active', a new tag will be created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ListsAPIPostListMemberTagsRequest
*/
func (a *ListsAPIService) PostListMemberTags(ctx context.Context, listId string, subscriberHash string) ListsAPIPostListMemberTagsRequest {
	return ListsAPIPostListMemberTagsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) PostListMemberTagsExecute(r ListsAPIPostListMemberTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListMemberTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIPostListsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	body *SubscriberList1
}

func (r ListsAPIPostListsRequest) Body(body SubscriberList1) ListsAPIPostListsRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsRequest) Execute() (*SubscriberList, *http.Response, error) {
	return r.ApiService.PostListsExecute(r)
}

/*
PostLists Add list

Create a new list in your Mailchimp account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ListsAPIPostListsRequest
*/
func (a *ListsAPIService) PostLists(ctx context.Context) ListsAPIPostListsRequest {
	return ListsAPIPostListsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscriberList
func (a *ListsAPIService) PostListsExecute(r ListsAPIPostListsRequest) (*SubscriberList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriberList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostLists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	body *MembersToSubscribeUnsubscribeToFromAListInBatch
	skipMergeValidation *bool
	skipDuplicateCheck *bool
}

func (r ListsAPIPostListsIdRequest) Body(body MembersToSubscribeUnsubscribeToFromAListInBatch) ListsAPIPostListsIdRequest {
	r.body = &body
	return r
}

// If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
func (r ListsAPIPostListsIdRequest) SkipMergeValidation(skipMergeValidation bool) ListsAPIPostListsIdRequest {
	r.skipMergeValidation = &skipMergeValidation
	return r
}

// If skip_duplicate_check is true, we will ignore duplicates sent in the request when using the batch sub/unsub on the lists endpoint. The status of the first appearance in the request will be saved. This defaults to false.
func (r ListsAPIPostListsIdRequest) SkipDuplicateCheck(skipDuplicateCheck bool) ListsAPIPostListsIdRequest {
	r.skipDuplicateCheck = &skipDuplicateCheck
	return r
}

func (r ListsAPIPostListsIdRequest) Execute() (*BatchUpdateListMembers, *http.Response, error) {
	return r.ApiService.PostListsIdExecute(r)
}

/*
PostListsId Batch subscribe or unsubscribe

Batch subscribe or unsubscribe list members.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIPostListsIdRequest
*/
func (a *ListsAPIService) PostListsId(ctx context.Context, listId string) ListsAPIPostListsIdRequest {
	return ListsAPIPostListsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return BatchUpdateListMembers
func (a *ListsAPIService) PostListsIdExecute(r ListsAPIPostListsIdRequest) (*BatchUpdateListMembers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchUpdateListMembers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.skipMergeValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_merge_validation", r.skipMergeValidation, "")
	}
	if r.skipDuplicateCheck != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_duplicate_check", r.skipDuplicateCheck, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdInterestCategoriesRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	body *InterestCategory1
}

func (r ListsAPIPostListsIdInterestCategoriesRequest) Body(body InterestCategory1) ListsAPIPostListsIdInterestCategoriesRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsIdInterestCategoriesRequest) Execute() (*InterestCategory, *http.Response, error) {
	return r.ApiService.PostListsIdInterestCategoriesExecute(r)
}

/*
PostListsIdInterestCategories Add interest category

Create a new interest category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIPostListsIdInterestCategoriesRequest
*/
func (a *ListsAPIService) PostListsIdInterestCategories(ctx context.Context, listId string) ListsAPIPostListsIdInterestCategoriesRequest {
	return ListsAPIPostListsIdInterestCategoriesRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return InterestCategory
func (a *ListsAPIService) PostListsIdInterestCategoriesExecute(r ListsAPIPostListsIdInterestCategoriesRequest) (*InterestCategory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InterestCategory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdInterestCategories")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdInterestCategoriesIdInterestsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	interestCategoryId string
	body *Interest1
}

func (r ListsAPIPostListsIdInterestCategoriesIdInterestsRequest) Body(body Interest1) ListsAPIPostListsIdInterestCategoriesIdInterestsRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsIdInterestCategoriesIdInterestsRequest) Execute() (*Interest, *http.Response, error) {
	return r.ApiService.PostListsIdInterestCategoriesIdInterestsExecute(r)
}

/*
PostListsIdInterestCategoriesIdInterests Add interest in category

Create a new interest or 'group name' for a specific category.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param interestCategoryId The unique ID for the interest category.
 @return ListsAPIPostListsIdInterestCategoriesIdInterestsRequest
*/
func (a *ListsAPIService) PostListsIdInterestCategoriesIdInterests(ctx context.Context, listId string, interestCategoryId string) ListsAPIPostListsIdInterestCategoriesIdInterestsRequest {
	return ListsAPIPostListsIdInterestCategoriesIdInterestsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		interestCategoryId: interestCategoryId,
	}
}

// Execute executes the request
//  @return Interest
func (a *ListsAPIService) PostListsIdInterestCategoriesIdInterestsExecute(r ListsAPIPostListsIdInterestCategoriesIdInterestsRequest) (*Interest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Interest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdInterestCategoriesIdInterests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/interest-categories/{interest_category_id}/interests"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"interest_category_id"+"}", url.PathEscape(parameterValueToString(r.interestCategoryId, "interestCategoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdMembersRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	body *AddListMembers1
	skipMergeValidation *bool
}

func (r ListsAPIPostListsIdMembersRequest) Body(body AddListMembers1) ListsAPIPostListsIdMembersRequest {
	r.body = &body
	return r
}

// If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
func (r ListsAPIPostListsIdMembersRequest) SkipMergeValidation(skipMergeValidation bool) ListsAPIPostListsIdMembersRequest {
	r.skipMergeValidation = &skipMergeValidation
	return r
}

func (r ListsAPIPostListsIdMembersRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.PostListsIdMembersExecute(r)
}

/*
PostListsIdMembers Add member to list

Add a new member to the list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIPostListsIdMembersRequest
*/
func (a *ListsAPIService) PostListsIdMembers(ctx context.Context, listId string) ListsAPIPostListsIdMembersRequest {
	return ListsAPIPostListsIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) PostListsIdMembersExecute(r ListsAPIPostListsIdMembersRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.skipMergeValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_merge_validation", r.skipMergeValidation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdMembersHashActionsDeletePermanentRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
}

func (r ListsAPIPostListsIdMembersHashActionsDeletePermanentRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostListsIdMembersHashActionsDeletePermanentExecute(r)
}

/*
PostListsIdMembersHashActionsDeletePermanent Delete list member

Delete all personally identifiable information related to a list member, and remove them from a list. This will make it impossible to re-import the list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ListsAPIPostListsIdMembersHashActionsDeletePermanentRequest
*/
func (a *ListsAPIService) PostListsIdMembersHashActionsDeletePermanent(ctx context.Context, listId string, subscriberHash string) ListsAPIPostListsIdMembersHashActionsDeletePermanentRequest {
	return ListsAPIPostListsIdMembersHashActionsDeletePermanentRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
func (a *ListsAPIService) PostListsIdMembersHashActionsDeletePermanentExecute(r ListsAPIPostListsIdMembersHashActionsDeletePermanentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdMembersHashActionsDeletePermanent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/actions/delete-permanent"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ListsAPIPostListsIdMembersIdNotesRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	body *MemberNotes1
}

func (r ListsAPIPostListsIdMembersIdNotesRequest) Body(body MemberNotes1) ListsAPIPostListsIdMembersIdNotesRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsIdMembersIdNotesRequest) Execute() (*MemberNotes, *http.Response, error) {
	return r.ApiService.PostListsIdMembersIdNotesExecute(r)
}

/*
PostListsIdMembersIdNotes Add member note

Add a new note for a specific subscriber.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address.
 @return ListsAPIPostListsIdMembersIdNotesRequest
*/
func (a *ListsAPIService) PostListsIdMembersIdNotes(ctx context.Context, listId string, subscriberHash string) ListsAPIPostListsIdMembersIdNotesRequest {
	return ListsAPIPostListsIdMembersIdNotesRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return MemberNotes
func (a *ListsAPIService) PostListsIdMembersIdNotesExecute(r ListsAPIPostListsIdMembersIdNotesRequest) (*MemberNotes, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MemberNotes
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdMembersIdNotes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}/notes"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdMergeFieldsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	body *MergeField1
}

func (r ListsAPIPostListsIdMergeFieldsRequest) Body(body MergeField1) ListsAPIPostListsIdMergeFieldsRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsIdMergeFieldsRequest) Execute() (*MergeField, *http.Response, error) {
	return r.ApiService.PostListsIdMergeFieldsExecute(r)
}

/*
PostListsIdMergeFields Add merge field

Add a new merge field for a specific audience.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIPostListsIdMergeFieldsRequest
*/
func (a *ListsAPIService) PostListsIdMergeFields(ctx context.Context, listId string) ListsAPIPostListsIdMergeFieldsRequest {
	return ListsAPIPostListsIdMergeFieldsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return MergeField
func (a *ListsAPIService) PostListsIdMergeFieldsExecute(r ListsAPIPostListsIdMergeFieldsRequest) (*MergeField, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MergeField
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdMergeFields")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/merge-fields"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdSegmentsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	body *List8
}

func (r ListsAPIPostListsIdSegmentsRequest) Body(body List8) ListsAPIPostListsIdSegmentsRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsIdSegmentsRequest) Execute() (*List7, *http.Response, error) {
	return r.ApiService.PostListsIdSegmentsExecute(r)
}

/*
PostListsIdSegments Add segment

Create a new segment in a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIPostListsIdSegmentsRequest
*/
func (a *ListsAPIService) PostListsIdSegments(ctx context.Context, listId string) ListsAPIPostListsIdSegmentsRequest {
	return ListsAPIPostListsIdSegmentsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return List7
func (a *ListsAPIService) PostListsIdSegmentsExecute(r ListsAPIPostListsIdSegmentsRequest) (*List7, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *List7
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdSegments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdSegmentsIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	segmentId string
	body *MembersToAddRemoveToFromAStaticSegment
}

func (r ListsAPIPostListsIdSegmentsIdRequest) Body(body MembersToAddRemoveToFromAStaticSegment) ListsAPIPostListsIdSegmentsIdRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsIdSegmentsIdRequest) Execute() (*BatchAddRemoveListMembersToFromStaticSegment, *http.Response, error) {
	return r.ApiService.PostListsIdSegmentsIdExecute(r)
}

/*
PostListsIdSegmentsId Batch add or remove members

Batch add/remove list members to static segment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ListsAPIPostListsIdSegmentsIdRequest
*/
func (a *ListsAPIService) PostListsIdSegmentsId(ctx context.Context, listId string, segmentId string) ListsAPIPostListsIdSegmentsIdRequest {
	return ListsAPIPostListsIdSegmentsIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return BatchAddRemoveListMembersToFromStaticSegment
func (a *ListsAPIService) PostListsIdSegmentsIdExecute(r ListsAPIPostListsIdSegmentsIdRequest) (*BatchAddRemoveListMembersToFromStaticSegment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchAddRemoveListMembersToFromStaticSegment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdSegmentsId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdSegmentsIdMembersRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	segmentId string
	body *PostListsIdSegmentsIdMembersRequest
}

func (r ListsAPIPostListsIdSegmentsIdMembersRequest) Body(body PostListsIdSegmentsIdMembersRequest) ListsAPIPostListsIdSegmentsIdMembersRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsIdSegmentsIdMembersRequest) Execute() (*ListMembers1, *http.Response, error) {
	return r.ApiService.PostListsIdSegmentsIdMembersExecute(r)
}

/*
PostListsIdSegmentsIdMembers Add member to segment

Add a member to a static segment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param segmentId The unique id for the segment.
 @return ListsAPIPostListsIdSegmentsIdMembersRequest
*/
func (a *ListsAPIService) PostListsIdSegmentsIdMembers(ctx context.Context, listId string, segmentId string) ListsAPIPostListsIdSegmentsIdMembersRequest {
	return ListsAPIPostListsIdSegmentsIdMembersRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		segmentId: segmentId,
	}
}

// Execute executes the request
//  @return ListMembers1
func (a *ListsAPIService) PostListsIdSegmentsIdMembersExecute(r ListsAPIPostListsIdSegmentsIdMembersRequest) (*ListMembers1, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers1
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdSegmentsIdMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments/{segment_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segment_id"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdSignupFormsRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	body *SignupForm1
}

func (r ListsAPIPostListsIdSignupFormsRequest) Body(body SignupForm1) ListsAPIPostListsIdSignupFormsRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsIdSignupFormsRequest) Execute() (*SignupForm, *http.Response, error) {
	return r.ApiService.PostListsIdSignupFormsExecute(r)
}

/*
PostListsIdSignupForms Customize signup form

Customize a list's default signup form.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIPostListsIdSignupFormsRequest
*/
func (a *ListsAPIService) PostListsIdSignupForms(ctx context.Context, listId string) ListsAPIPostListsIdSignupFormsRequest {
	return ListsAPIPostListsIdSignupFormsRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return SignupForm
func (a *ListsAPIService) PostListsIdSignupFormsExecute(r ListsAPIPostListsIdSignupFormsRequest) (*SignupForm, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignupForm
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdSignupForms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/signup-forms"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPostListsIdWebhooksRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	body *AddWebhook
}

func (r ListsAPIPostListsIdWebhooksRequest) Body(body AddWebhook) ListsAPIPostListsIdWebhooksRequest {
	r.body = &body
	return r
}

func (r ListsAPIPostListsIdWebhooksRequest) Execute() (*ListWebhooks, *http.Response, error) {
	return r.ApiService.PostListsIdWebhooksExecute(r)
}

/*
PostListsIdWebhooks Add webhook

Create a new webhook for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIPostListsIdWebhooksRequest
*/
func (a *ListsAPIService) PostListsIdWebhooks(ctx context.Context, listId string) ListsAPIPostListsIdWebhooksRequest {
	return ListsAPIPostListsIdWebhooksRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return ListWebhooks
func (a *ListsAPIService) PostListsIdWebhooksExecute(r ListsAPIPostListsIdWebhooksRequest) (*ListWebhooks, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListWebhooks
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PostListsIdWebhooks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/webhooks"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPreviewASegmentRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	fields *[]string
	excludeFields *[]string
	count *int32
	offset *int32
	type_ *string
	sinceCreatedAt *string
	beforeCreatedAt *string
	includeCleaned *bool
	includeTransactional *bool
	includeUnsubscribed *bool
	sinceUpdatedAt *string
	beforeUpdatedAt *string
}

// A comma-separated list of fields to return. Reference parameters of sub-objects with dot notation.
func (r ListsAPIPreviewASegmentRequest) Fields(fields []string) ListsAPIPreviewASegmentRequest {
	r.fields = &fields
	return r
}

// A comma-separated list of fields to exclude. Reference parameters of sub-objects with dot notation.
func (r ListsAPIPreviewASegmentRequest) ExcludeFields(excludeFields []string) ListsAPIPreviewASegmentRequest {
	r.excludeFields = &excludeFields
	return r
}

// The number of records to return. Default value is 10. Maximum value is 1000
func (r ListsAPIPreviewASegmentRequest) Count(count int32) ListsAPIPreviewASegmentRequest {
	r.count = &count
	return r
}

// Used for [pagination](https://mailchimp.com/developer/marketing/docs/methods-parameters/#pagination), this it the number of records from a collection to skip. Default value is 0.
func (r ListsAPIPreviewASegmentRequest) Offset(offset int32) ListsAPIPreviewASegmentRequest {
	r.offset = &offset
	return r
}

// Limit results based on segment type.
func (r ListsAPIPreviewASegmentRequest) Type_(type_ string) ListsAPIPreviewASegmentRequest {
	r.type_ = &type_
	return r
}

// Restrict results to segments created after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIPreviewASegmentRequest) SinceCreatedAt(sinceCreatedAt string) ListsAPIPreviewASegmentRequest {
	r.sinceCreatedAt = &sinceCreatedAt
	return r
}

// Restrict results to segments created before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIPreviewASegmentRequest) BeforeCreatedAt(beforeCreatedAt string) ListsAPIPreviewASegmentRequest {
	r.beforeCreatedAt = &beforeCreatedAt
	return r
}

// Include cleaned members in response
func (r ListsAPIPreviewASegmentRequest) IncludeCleaned(includeCleaned bool) ListsAPIPreviewASegmentRequest {
	r.includeCleaned = &includeCleaned
	return r
}

// Include transactional members in response
func (r ListsAPIPreviewASegmentRequest) IncludeTransactional(includeTransactional bool) ListsAPIPreviewASegmentRequest {
	r.includeTransactional = &includeTransactional
	return r
}

// Include unsubscribed members in response
func (r ListsAPIPreviewASegmentRequest) IncludeUnsubscribed(includeUnsubscribed bool) ListsAPIPreviewASegmentRequest {
	r.includeUnsubscribed = &includeUnsubscribed
	return r
}

// Restrict results to segments update after the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIPreviewASegmentRequest) SinceUpdatedAt(sinceUpdatedAt string) ListsAPIPreviewASegmentRequest {
	r.sinceUpdatedAt = &sinceUpdatedAt
	return r
}

// Restrict results to segments update before the set time. Uses ISO 8601 time format: 2015-10-21T15:41:36+00:00.
func (r ListsAPIPreviewASegmentRequest) BeforeUpdatedAt(beforeUpdatedAt string) ListsAPIPreviewASegmentRequest {
	r.beforeUpdatedAt = &beforeUpdatedAt
	return r
}

func (r ListsAPIPreviewASegmentRequest) Execute() (*CollectionOfSegments, *http.Response, error) {
	return r.ApiService.PreviewASegmentExecute(r)
}

/*
PreviewASegment List segments

Get information about all available segments for a specific list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPIPreviewASegmentRequest
*/
func (a *ListsAPIService) PreviewASegment(ctx context.Context, listId string) ListsAPIPreviewASegmentRequest {
	return ListsAPIPreviewASegmentRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return CollectionOfSegments
func (a *ListsAPIService) PreviewASegmentExecute(r ListsAPIPreviewASegmentRequest) (*CollectionOfSegments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfSegments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PreviewASegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/segments"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "csv")
	}
	if r.excludeFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_fields", r.excludeFields, "csv")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	} else {
		var defaultValue int32 = 10
		r.count = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.sinceCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_created_at", r.sinceCreatedAt, "")
	}
	if r.beforeCreatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_created_at", r.beforeCreatedAt, "")
	}
	if r.includeCleaned != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_cleaned", r.includeCleaned, "")
	}
	if r.includeTransactional != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_transactional", r.includeTransactional, "")
	}
	if r.includeUnsubscribed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_unsubscribed", r.includeUnsubscribed, "")
	}
	if r.sinceUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_updated_at", r.sinceUpdatedAt, "")
	}
	if r.beforeUpdatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before_updated_at", r.beforeUpdatedAt, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPIPutListsIdMembersIdRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	subscriberHash string
	body *AddListMembers2
	skipMergeValidation *bool
}

func (r ListsAPIPutListsIdMembersIdRequest) Body(body AddListMembers2) ListsAPIPutListsIdMembersIdRequest {
	r.body = &body
	return r
}

// If skip_merge_validation is true, member data will be accepted without merge field values, even if the merge field is usually required. This defaults to false.
func (r ListsAPIPutListsIdMembersIdRequest) SkipMergeValidation(skipMergeValidation bool) ListsAPIPutListsIdMembersIdRequest {
	r.skipMergeValidation = &skipMergeValidation
	return r
}

func (r ListsAPIPutListsIdMembersIdRequest) Execute() (*ListMembers2, *http.Response, error) {
	return r.ApiService.PutListsIdMembersIdExecute(r)
}

/*
PutListsIdMembersId Add or update list member

Add or update a list member.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @param subscriberHash The MD5 hash of the lowercase version of the list member's email address. This endpoint also accepts a list member's email address or contact_id.
 @return ListsAPIPutListsIdMembersIdRequest
*/
func (a *ListsAPIService) PutListsIdMembersId(ctx context.Context, listId string, subscriberHash string) ListsAPIPutListsIdMembersIdRequest {
	return ListsAPIPutListsIdMembersIdRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
		subscriberHash: subscriberHash,
	}
}

// Execute executes the request
//  @return ListMembers2
func (a *ListsAPIService) PutListsIdMembersIdExecute(r ListsAPIPutListsIdMembersIdRequest) (*ListMembers2, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMembers2
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.PutListsIdMembersId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/members/{subscriber_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"subscriber_hash"+"}", url.PathEscape(parameterValueToString(r.subscriberHash, "subscriberHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.skipMergeValidation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_merge_validation", r.skipMergeValidation, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ListsAPISearchTagsByNameRequest struct {
	ctx context.Context
	ApiService ListsAPI
	listId string
	name *string
}

// The search query used to filter tags.  The search query will be compared to each tag as a prefix, so all tags that have a name starting with this field will be returned.
func (r ListsAPISearchTagsByNameRequest) Name(name string) ListsAPISearchTagsByNameRequest {
	r.name = &name
	return r
}

func (r ListsAPISearchTagsByNameRequest) Execute() (*TagSearchResults, *http.Response, error) {
	return r.ApiService.SearchTagsByNameExecute(r)
}

/*
SearchTagsByName Search for tags on a list by name.

Search for tags on a list by name. If no name is provided, will return all tags on the list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param listId The unique ID for the list.
 @return ListsAPISearchTagsByNameRequest
*/
func (a *ListsAPIService) SearchTagsByName(ctx context.Context, listId string) ListsAPISearchTagsByNameRequest {
	return ListsAPISearchTagsByNameRequest{
		ApiService: a,
		ctx: ctx,
		listId: listId,
	}
}

// Execute executes the request
//  @return TagSearchResults
func (a *ListsAPIService) SearchTagsByNameExecute(r ListsAPISearchTagsByNameRequest) (*TagSearchResults, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TagSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListsAPIService.SearchTagsByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lists/{list_id}/tag-search"
	localVarPath = strings.Replace(localVarPath, "{"+"list_id"+"}", url.PathEscape(parameterValueToString(r.listId, "listId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetailDocument
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
